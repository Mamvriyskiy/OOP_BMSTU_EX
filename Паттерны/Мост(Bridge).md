### Идея

Имеются следующие проблемы:
1. У нас большая иерархия. В иерархии возможно несколько внутренних реализаций для объекта, это разные классы, разные ветви. У нас один объект, и во время работы надо поменять реализацию. Каким-то образом нам надо мигрировать от одного класса к другому.
2. Постоянно происходит дублирование кода, когда у нас разрастается иерархия классов.

Предложено **разделить понятие самого объекта, его сущности и реализации, в отдельные иерархии** . Таким образом, мы сократим количество классов и сделаем систему более гибкой. Мы во время работы сможем менять реализацию. Мы можем уйти (не полностью, частично) от повторного кода.

Паттерн Мост (или Bridge) отделяет саму абстракцию, сущность, от реализаций. Мы можем независимо менять логику (сами абстракции) и наращивать реализацию (добавлять новые классы реализации).

![[bridge.png]]

>Таким образом, для каждого объекта мы можем менять реализацию динамически в любой момент во время выполнения. Как логика самого объекта может меняться, так и реализация может меняться. Мы независимо от сущности добавляем реализации и наоборот.

>Возникает проблема выноса связи на уровень базового класса. Есть проблема, не всегда это удается сделать.

### Использование
1. Нам нужно во время выполнения менять реализацию
2. Когда у нас большая иерархия, и по разным ветвям этой иерархии идут одинаковые реализации. **Дублирование кода мы выносим в дерево реализаций**. Такой подход дает возможность независимо изменять управляющую логику и реализацию.

**Преимущества:**
- убирает дублирование кода
- Нет разрастания иерархии
- Во время выполнения программы можно менять реализацию
- Еще один слой защиты нашей реализации

**Недостатки:**
- Не всегда можно свести к связи между абстрактными базовыми понятиями, в таком случае придется вводить связи между конкретными сущностями и лишиться подмены.
- При вызове метода сущности вызывается метод реализации, что увеличивает время работы.

```c++
# include <iostream>
# include <memory>

using namespace std;

class Implementor
{
public:
	virtual ~Implementor() = default;

	virtual void operationImp() = 0;
};

class Abstraction
{
protected:
	shared_ptr<Implementor> implementor;

public:
	Abstraction(shared_ptr<Implementor> imp) : implementor(imp) {}
	virtual ~Abstraction() = default;

	virtual void operation() = 0;
};

class ConImplementor : public Implementor
{
public:
	virtual void operationImp() override { cout << "Implementor;" << endl; }
};

class Entity : public Abstraction
{
public:
	using Abstraction::Abstraction;

	virtual void operation() override { cout << "Entity: "; implementor->operationImp(); }
};

int main()
{
	shared_ptr<Implementor> implementor = make_shared<ConImplementor>();
	shared_ptr<Abstraction> abstraction = make_shared<Entity>(implementor);

	abstraction->operation();
}

```
