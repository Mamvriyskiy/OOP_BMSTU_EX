>Паттерн Шаблонный метод (Template method) реализует идею разделения решения некоторой задачи на этапы, каждый из которых может быть реализован каким-либо алгоритмом.

![[tm.png]]


**Преимущества паттерна:**
- Даёт возможность предоставить свою реализацию метода.
- Позволяет избежать дублирование кода в классах-наследниках за счёт выноса общей логики алгоритма в абстрактный класс.
- Упрощает расширение функциональности при помощи изменения порядка выполнения шагов в классах-наследниках без изменения общей структуры алгоритма.

**Недостатки паттерна:**
- Может усложнить понимание кода.
- Может привести к созданию большого числа классов-наследников, если алгоритм имеет большое число шагов, каждый из которых должен быть изменен в отдельном подклассе.

## Реализация частей метода в классе-наследнике

>В данной реализации выделяемые части шаблонного метода реализуются в классе-наследнике класса, содержащего шаблонный метод.

>Данный подход может быть использован, когда необходимо позволить переопределить выполнение метода, либо менять отдельные его части, определяя их “ниже” по иерархии наследования.
## Реализация отдельных частей алгоритма в разных классах

Данный подход использует идиому MixIn для разделения частей шаблонного метода между разными классами, которые затем “примешиваются” к результирующему классу, позволяя выбирать стратегию для каждого этапа независимо на этапе компиляции.

Данный подход может использоваться в случае, если требуется разделить реализации разных частей, при этом сохраняя независимость классов друг от друга.


```c++
# include <iostream>

using namespace std;

class AbstractClass
{
public:
void templateMethod()
{
	primitiveOperation();
	concreteOperation();
	hook();
}
virtual ~AbstractClass() = default;

protected:
	virtual void primitiveOperation() = 0;
	void concreteOperation() { cout << "concreteOperation;" << endl; }
	virtual void hook() { cout << "hook Base;" << endl; }
};

class ConClassA : public AbstractClass
{
protected:
	void primitiveOperation() override { cout << "primitiveOperation A;" << endl; }
};

class ConClassB : public AbstractClass
{
protected:
	void primitiveOperation() override { cout << "primitiveOperation B;" << endl; }
	void hook() override { cout << "hook B;" << endl; }
};

int main()
{
	ConClassA ca;
	ConClassB cb;
	
	ca.templateMethod();
	cb.templateMethod();
}

```

