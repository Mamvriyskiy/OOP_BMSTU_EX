>Паттерн Хранитель (Holder) позволяет реализовать идиому RAII путем удержания некоторого ресурса и обеспечения управления его жизненным циклом за счет связи жизни объекта-хранителя на стеке с жизнью объекта-ресурса.

**Преимущества паттерна:**
- Помогает избежать утечек памяти
- Может быть использован для управления временем жизни различных ресурсов

**Недостатки паттерна:**
- Опасность наличия операции взятия адреса, что требует её удаления.
## Управление динамической памятью

Используется для решения проблем утечки памяти путём автоматического освобождения выделенной памяти при разрушении объекта-хранителя, находящегося на стеке. Помимо этого, могут использоваться различные вариации, обеспечивающие разделенное или единоличное хранение ресурса. Реализовано в стандартной библиотеке в классах std::unique_ptr, std::shared_ptr. Код примера реализации простого хранителя для работы с динамически выделенной памятью приведен на листинге 16.

## Управление блокировками в многопоточном коде

Используется при работе с многопоточным кодом и объектами, требующими блокировки. В стандартной библиотеке реализован в классах std::lock_guard, std::unique_lock, std::shared_lock.

```c++
template <typename Т>
class raii_ptr {
public:
	expltcit raii_ptr(T* р) : р_( р) {}
	~raii_ptr() { delete р_; }

	Т* operator->( ) { return р_; }
	const Т* operator->( ) const { return р_; }
	Т& operator* () { return *р_; }
	const Т& operator*( ) const { return *р_; }

private:
	T* p_;
};
```