**МВО** - модель взаимодействия объектов. Мы рассматриваем только нашу подсистему или домен. Что ВОВНЕ нас не интересует, но ИЗВНЕ могут приходить события.

МДО - взаимодействие синхронное, а в МВО - асинхронное.
#### Все события разделяем на две группы:
1. Внешние события, которые приходят **извне**.  
2. События, которые происходят **внутри** нашей подсистемы.
    
>На МВО мы ограничиваем нашу подсистему сверху и снизу. Ограничения сверху и снизу называют **терминаторами**. Соответственно, могут быть терминаторы верхнего уровня и терминаторы нижнего уровня (прямоугольничек).

>Наши объекты, а лучше сказать, модели состояний, рисуем овалами. Сверху располагаются модели состояний объектов, которые более осведомлены обо всей системе, внизу - менее осведомленные. Внешние события (которые приходят извне) приходят от терминаторов.

#### Внешние события разделяем на две группы:

1. **Незапрашиваемые** - не являются следствием предыдущего действия нашей подсистемы.
2. **Запрашиваемые** - являются результатом действия нашей подсистемы.

>Почему мы делим на запрашиваемые и незапрашиваемые? Так как в дальнейшем мы должны проанализировать работу нашей подсистемы.

>Приходит событие извне и объект наш может менять состояние. Мы должны четко проанализировать, какие события принимает наша модель состояний, и какие события она может порождать для других объектов. Причем эти события могут быть как вверх, так вниз. События могут уходить к терминатору.

![[ter.png]]

#### В зависимости от того, откуда пришло не запрашиваемое событие, рассматриваем схемы:

1. **Схема верхнего управления** - не запрашиваемое событие пришло от терминатора верхнего уровня.
2. **Схема нижнего управления** - не запрашиваемое событие пришло от терминатора нижнего уровня.

Мы нарисовали модель взаимодействия объектов в нашей подсистеме, но хотелось бы проследить, как изменяются состояния объектов нашей подсистемы с приходом какого-либо не запрашиваемого события извне. Это важный момент! Для того чтобы проверить корректность нашей модели, мы должны перебрать все возможные варианты. Здесь необходимо так называемое моделирование: мы генерируем всевозможные начальные состояния объектов нашей подсистемы, и для каждого набора начальных состояний анализируем, как в этом начальном состоянии система реагирует на все не запрашиваемые события. И так для каждой генерации.

## Каналы управления

Для удобства моделирования строятся **каналы управления**. В предыдущем примере мы рисовали иерархию, выстраивал её из объектов. В отличие от него, **в каналах управления каждая модель состояния - это вертикальная линия**.
### Пример с преподавателем и студентом

1. Тассов говорит: "В каналах управления каждая модель состояния - это вертикальная линия... преподаватель... студент... и так далее".
    
2. Приходит незапрашиваемое событие. Преподаватель, допустим, находится в каком-то состоянии. В прямоугольниках мы рисуем состояние объекта. Стрелка извне означает, что приходит незапрашиваемое событие.
    
    **Важный момент!** Очень часто нам важно модель построить именно с учетом временных рамок.
    
    ###### Выделяем здесь два времени:
    - **Время задержки** - это то время, которое объект должен находиться в этом состоянии. Например, для дверей есть состояние "_двери закрываются_". Закрытие дверей не происходит мгновенно, это происходит за какое то время. Это время записывается вне прямоугольника.
    - **Время выполнения действия** - время, которое переводит объект в это состояние. Это время записывается внутри прямоугольника.
    
    **Для нас критично, когда время действия становится больше времени задержки.**
    
3. Действие может породить событие для объекта самого себя, и так же оно может породить событие для других объектов.
    Пришло незапрашиваемое событие "_принять зачет у студента_". И преподаватель может перевести студента из одного состояния в другое и в результате события проставить зачет. В результате студент переходит из состояния "_без зачета_" в состояние "_с зачетом_".

![[ku.png]]

>Если время действия больше времени состояния, то нельзя построить модель.
### Окончательное состояние

**Нам важно, чтобы наша подсистема пришла в какое-то окончательное состояние.** Не может быть такого, что система не приходит в окончательное состояние. Значит, мы где-то значит допустили ошибку, что-то надо менять. Канал управления должен иметь конец, то есть все объекты, которые мы выделили, должны прийти в какое-то окончательное состояние.
#### Подведение итогов

Каналы управления - это процесс очень долгий, муторный, выполнять его крайне тяжело.

Процесс имитирования каналов управления:
1. Сгенерировать все начальные состояния.
2. Для каждой генерации принять все незапрашиваемые события.
3. Мы должны прийти в какие то окончательные состояния.