> **Полная формулировка вопроса:** Преимущества и недостатки структурного программирования. Идеи Энтони Хоара. Преимущества и недостатки объектно-ориентированного программирования.

#### Преимущества этой технологии:
1. Самые серьезные логические ошибки исправляются на ранних стадиях разработки.
2. Объединение этапов - проектирования, кодирования, тестирования (примечание в ООП будут проблемы)
3. Взаимодействие с заказчиком на ранней стадии
4. Легко распределяются задачи между программистами
5. При таком подходе нет "кода в корзину".
6. Начиная с самых ранних стадий идет взаимодействие с заказчиком.
7. Объединение этапов кодирования, проектирования и тестирования (параллельно происходит).
8. Комплексная отладка - тесты пишутся до этапа проектирования на основе ТЗ.
9. Удобное распределение работы между программистами.
10. Из-за многоуровневой абстракции возникают естественные контрольные точки за наблюдением за проектом.
11. Локализация ошибок. (много уровней абстракции, легко выявить где).
12. Вероятность невыполнения проекта сводится к нулю.
13. Повторное использование кода, выделяются библиотеки.
14. Плавное распределение ресурсов при разработке программного продукта. Нет аврала в конце проекта.
15. На начальном этапе используется иерархический подход (на этапе распределения ролей), а потом операционный(разработка).
16. Проще писать код, проще читать код

>На начальном этапе используется иерархический подход (на этапе распределения ролей), а потом операционный(разработка).

>Иерархический - порядок программирования и тестирования модулей определяется их расположением в схеме иерархии.

>Операционный - модули разрабатываются в порядке их выполнения при запуске готовой программы.

#### Недостатки этой технологии:

**Сложно модифицировать код:**
1. Понижение надежности за счет внесения изменений в написанный **чужой** код (плюс трата времени на разбор чужого кода).
2. Изменение данных, следовательно программа сыпется. Возникают моменты, когда легче написать свою программу с нуля.
3. Исключительные ситуации обрабатываются вперемешку с логикой кода - это приводит к большому количеству проверок и необходимости "протаскивать" ошибку чрез весь код до того места, где её можно будет обработать.

## Идеи Энтони Хоара

1. Если в программе меняется данное, то в структурном подходе мы вынуждены выявить все места, где оно используется и внести изменения в **написанный** код.
    
    В ООП мы выносим действие над данным! Это не связка с другими данными! Эта идея называется инкапсуляцией. **Инкапсуляция** - объединение данных и действий над данными. Работа с данными идет только через действие.
    
    _Пример: работа со структурой File в Qt и других программах. Поля разные, а функции одинаковые._
    
2. Изменение кода - понижение надежности. Для модификации программных сущностей использовать при возможности надстройку над существующими сущностями. Это **наследование** - надстройка над тем, что существует (возможность сокрытия/добавления полей/функций). Хоар не выделял это как требование, оно утвердилось позже.
    
    Безразличие к тому, что представляет функционал - **полиморфизм**. **Полиморфизм** — это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
    
    Формирование понятия: данные + действия. Возможность изменения как самих данных, так и надстройки без изменения самих данных.
    
3. Перенос взаимодействия из физического мира в программу. **Синхронное** (accessорное) взаимодействие или **асинхронное** (событийное) **взаимодействие**. **Синхронное взаимодействие** - вызов метода (если объект), функции. **Асинхронное взаимодействие** - событие произошло, изменение объекта или его состояния произойдут со временем, на уровне ЯП реализовать невозможно. Поддержка должна быть на другом уровне.
    
> Сначала начали реализовывать операционные оболочки. Сейчас это поддерживается на уровне ОС.

## Преимущества ООП
- Все недостатки пусты перед тем, что мы можем легко модифицировать программу.
- Более гибкая система, код легче поддерживать -> возможность легкой модификации (при грамотном анализе и проектировании) -> увеличивается показатель повторного использования кода.
- Более "естественная" декомпозиция ПО, которая существенно облегчает разработку.
- Сокращение количества межмодульных вызовов и уменьшение объемов информации, передаваемой между модулями.

## Недостатки ООП
- Невозможность совмещения этапов проектирования, кодирования, тестирования (что в структурном возможно). Сначала нужно построить начальную модель, потом рекурсивный дизайн, то есть эту модель мы можем развивать.
- В структурном подходе(СП) порог вхождении очень низкий, то есть вы сразу может начать писать программу используя СП. А что касается ООП порог вхождения выше и это проблема, требуется более высокая классификация программиста.
- Программист и проектировщик, и кодировщик. Другие требования к квалификации.
- Размер кода резко возрастает - резко увеличивается время выполнения, объем необходимой памяти увеличивается. Гораздо больше времени тратится на проектирование. В структурном подходе лавинный вызов метода.
- В СП легко контролировать ресурсы и правила черного ящика(если какая-то функция не может выполниться она не должна захватывать ресурс, при возвращении ресурса ответственность переходит на вызывающую программу). Что касается ООП - задача разбивается на куски, например, если проблема с утечкой памяти, ее определили и выявили место где ошибка, то не всегда можно избавиться от утечки памяти. Раньше в ООП программах были с утечками, сейчас более менее нормально. В принципе с С11 есть механизмы борьбы с проблемами памятью - **висящие указатели**.
- Возникновение "мертвого кода"(использую Qt Design не все используется, какие-то классы, члены, методы, характеристики) при модификации. Это занимает место, висит в памяти. Борьба с мертвым кодом - компилируется только тот код, который вызывается.

>