>Используется язык объектно-ориентированного программирования (Object-Oriented design language - OODLE)

В этой нотации выделяется 4 диаграммы:
- Диаграмма класса - диаграмма внешнего представления одного класса – Гради Буч
- Схема структуры класса – чтоб оказать внутреннюю структуру класса и доступа к данным
- Диаграмма зависимостей – показывает дружественные связи и клиент-серверный доступ
- Диаграмма наследования

>Последние две диаграммы в других нотациях как правило объединяются одной диаграммой.
## Диаграмма класса

Мы проектируем класс вокруг данных, атрибутов этого класса. У нас есть информационная модель, в которой мы выделили каждую сущностью, и каждая сущность для нас должна быть классом. У нас есть имя этой сущности(имя класса) , есть данные, есть атрибуты этого класса, которые становятся компонентами или членами класса при проектировании.

Когда мы выделяли атрибуты, мы четко перечисляли значения, которые может принимать атрибут для разных объектов. Это перечисление нам теперь необходимо для того, чтобы понять какого типа будет компонент.

Имя компонента берём то, которое уже было на информационной модели. И на основе тех значений, которые может принимать атрибут, определяем тип компонента. На диаграмме рисуется так:

![](https://camo.githubusercontent.com/b6bf3860d435965e04f93ef04ebd55c7a1f2293714ae64b4f595f417df731836/68747470733a2f2f73756e392d31302e757365726170692e636f6d2f3238787464624a4c6b3338626f5f324a6e554a35515551464f2d49663271416d4544732d32412f465a4b4f5352337a2d4d492e6a7067)

Так делаем для каждого компонента.

Для каждой сущности мы выделяем идентификатор. Если идентификатор (не?)формальный, то на диаграмме классов мы его не записываем, то есть при проектировании мы его убираем. А если это формальный атрибут, то на диаграмме мы это преобразуем в компонент. Прим.: на видео Тассов не очень внятно сказал, поэтому я не понял где формальный, а где нет.

Таким образом мы рассмотрели то, что внутри диаграммы класса.

Теперь наша задача выявить те методы, которые мы можем выполнять над нашим объектом. Стоит сказать, что все методы мы можем разделить на 2 группы:

1. Операции над объектом
2. Операции над классом С правой стороны рисуются операции над классом, с левой стороны над объектом.

Примером операции над классом является операция “создать”. Дело в том, что, когда мы используем эту операцию, объекта ещё нет. Объект появляется после выполнения этой операции. Это может быть конструктор или какой-то статический метод, который порождает объект данного класса.

Для операции мы рисуем линию, на которой мы должны показать какие данные получает процесс, какие изменяет, какие возвращают. Над линией мы показываем данные, которые получает. На самой линии изменяемые параметры. Под линией возвращаемые параметры:

![](https://camo.githubusercontent.com/6a0ee07ec18012c7fe3fe9b66f0f6683f6514608d866707fbc4a4a1be75aed21/68747470733a2f2f73756e392d36302e757365726170692e636f6d2f696f565133646b67786e59323243365a5f4b67504643364c71426e5754335577684e2d6731772f723652595275344139756b2e6a7067)

Когда речь идет об операции создания, нас интересуют только получаемые данные. Результатом является объект, но мы это не указываем на диаграмме. Получаемые компоненты мы рисуем аналогично членам самого класса.

![](https://camo.githubusercontent.com/7cb0497eb4d864095b771d665801694459682e8ed4dec1ef6dee2e73efdb7067/68747470733a2f2f73756e392d352e757365726170692e636f6d2f7641505f464b4f70676c517a745a77322d37536e7278683766505664667976672d6a6d4f4e412f2d4157356d506751574c552e6a7067)

Если метод обрабатывает исключительную ситуацию, то мы у него рисуем ромбик:

![](https://camo.githubusercontent.com/2d278b219776dc4834557f58213f821d01913adaee4196790e191f416b8d948f/68747470733a2f2f73756e392d37302e757365726170692e636f6d2f663867495661686c6c34447a745f7849495936425972707935377a536932724878435a414d412f34496b346944644674644d2e6a7067)

Если метод связан и вызывается во время выполнения, мы помечаем его чертой. Это обработчик состояний:

![](https://camo.githubusercontent.com/ee9a521df30b6210ae8ce9d4b42710b34d512f447984af37eac4b309827e0ede/68747470733a2f2f73756e392d31362e757365726170692e636f6d2f374f52462d6b73484d396779674d5a756c4341735332794264302d47444c4c714c746c4854772f646b566549656e72566e732e6a7067)

Если метод скрытый, то в принципе его можно помечать на диаграмме, но нас тут интересует интерфейс. Но отметить некоторые операции, которые происходят внутри, можно. В таком случае мы не рассматриваем данные, которые они получают. Если класс перегружен, то можно вообще эти классы не зарисовывать.

![](https://camo.githubusercontent.com/3730a08493901753b02b725b33a40355b8b4741f00d66568c0fe9c0b1569789b/68747470733a2f2f73756e392d35302e757365726170692e636f6d2f6874697a696373384f4243363858376c776737656b3267516b44556977464c622d4d453831412f35466c6c6251715730786f2e6a7067)

Возможно такое, что метод принимает или возвращает несколько данных. Тогда мы рисуем тот же “гробик” и приписываем N:

![](https://camo.githubusercontent.com/43f6e050c58a0d98c8632df2e8a664cfb638e5556bed2039b88616de12406f61/68747470733a2f2f73756e392d33332e757365726170692e636f6d2f687137727055344d583578594b715343716b707179724d7163437439524164446950485639672f38734a70736833507742732e6a7067)

Диаграмма внешнего представления одного класса

![](https://camo.githubusercontent.com/b6b53dd9ec41ab7f7597628605deb82297485e0e85581f1da9b0356fa05ce6a7/68747470733a2f2f73756e392d31392e757365726170692e636f6d2f645f434563546e41374b6b3048446a4d4a495a6d424a585937786a55325a7934304c6c6a35672f73335758644234325051672e6a7067)

## Вторая схема. Структура класса.

Наша задача проследить потоки данных и доступ к непосредственно данным самого класса. На данной диаграмме всё строится вокруг данных объектов. Это то, что на дпдд мы называли архивом данных. Вот он:

![](https://camo.githubusercontent.com/5c72401ab16f149c666badcaa73982108a2fea7b257909674eaf1b032d05bcc2/68747470733a2f2f73756e392d34312e757365726170692e636f6d2f434468447a7131704d4b6a6277412d68446d3445317061784a714e50554a506e4d34386830772f574f5965746e50374566492e6a7067)

Допустим у нас есть методы. Здесь задача четко посмотреть какие это методы. Нас интересовать будут не только методы, которые получают данные извне, но ещё и методы, которые используют методы, которые вызываются извне(сложна, не?).

Например, есть три метода.

Мы соединяем их линиями. Линии - это линии по доступу передачи данных. На каждой линии мы показываем какие данные получает метод и какие возвращает. Опять рисуем гробики. Если стрелочка вниз, это параметр, которые принимает метод. Если стрелочка вверх, то возвращает. Если и вверх и вниз, то и то, и другое:

![ААА ПИКЧА](https://camo.githubusercontent.com/979f5fb32b57d3b15dee99312ec534f0e6e26614e8a59f34f847178162b42a69/68747470733a2f2f73756e392d31392e757365726170692e636f6d2f676658616d777a344b6c496c303955316e346333544f687332515a59317363424b74784346412f6445656864705251714e512e6a7067)

Мы четко выделяем слои. Слой методов, которые вызываются извне – общедоступные, и методы скрытные, которые не вызываются извне. Желательно, чтоб методы интерфейса не вызывали друг друга. Если есть что-то общее в разных методах, то мы выделяем метод скрытого слоя, который объединяет эти методы общедоступного слоя. Четко прослеживаются потоки данных

Если метод обрабатывает исключения, выделяем квадратиком:

![ПИКЧА СНОВА](https://camo.githubusercontent.com/ff19299e911925ecd1e6a25779063727642cdf51873f760a52f1e82b1b4f4c4e/68747470733a2f2f73756e392d32352e757365726170692e636f6d2f6632644d766363537661396447755968496e64567559786c4b3475695139567444596c6a57772f3731614f647671746b31342e6a7067)

Если метод, получает или передает как результат какие-то данные во внешний модуль, то мы показываем это таким образом:

![КАРтинка обыкновенная](https://camo.githubusercontent.com/6ee396a1e8b07d2b1ec59ba44ff24e350d48d38286fcbb5cc1ee29a881c62d25/68747470733a2f2f73756e392d392e757365726170692e636f6d2f6d444c42504c5f756e53526f344f737a766f526730557a42486e6e31626476345244644f71412f42796d35304f75393343512e6a7067)

Общий вид схемы:

![Тассоу - пажилой сэкс](https://camo.githubusercontent.com/83af3dd4bece24c421665add2b9c39d285c4956ce7fcf8d68b42e320ac811480/68747470733a2f2f73756e392d36352e757365726170692e636f6d2f4a31345a6567437a6b64324a74516f797a706850423341462d676d627968766b54346c4f7a512f596e7772524e564855686b2e6a7067)

На схеме структуры класса четко прослеживаются потоки данных.

## Диаграмма зависимостей

На диаграмме зависимостей на нужно имя класса и возможно те методы, которые участвуют во взаимодействии.

Двойная стрелочка – дружественные связи, одна – схема использования. На этой диаграмме можно показать, какой метод имеет доступ к методу другого класса и какой метод вызывается

![Диаграмма зависимостей](https://camo.githubusercontent.com/ffe326e4b4a46afeb5dca915bb80e87dbf40d1771063a42a598446cce6af24c9/68747470733a2f2f73756e392d35392e757365726170692e636f6d2f4f3442616d67476a5f614c73587565787a623557316253666f37475543795378555a594134672f314e6f536c784a624533672e6a7067)

## Диаграмма наследования

На данной диаграмме нас интересуют какие методы и компоненты объектов.

Нам надо четко понимать какие компоненты есть у суперкласса и подклассов, и какие методы. Напомним, что в объектно-ориентированном анализе у нас суперкласс всегда абстрактный. К этому надо стремиться и при проектировании.

![Опа, диаграмма наследования](https://camo.githubusercontent.com/7eef3fbdfc5e7f046f7b86238679dc0c69b6acba43082394f3f28d2c68163271/68747470733a2f2f73756e392d362e757365726170692e636f6d2f696f5642374c7039364e692d496b7659477a5f5745687443493138686d416e614978364133412f4673453362566d514d6d772e6a7067)


