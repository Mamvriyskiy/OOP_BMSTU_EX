>**Полная формулировка вопроса:** Модель поведения объектов. Жизненный цикл и диаграмма перехода в состояния (ДПС). Виды состояний. События, данные событий. Действия состояний. Таблица перехода в состояния (ТПС). Правила переходов.
## Модель Мура

Для описания поведения объектов мы используем **модель Мура**.

**Она включает в себя**:
- множество состояний объекта (стадий);
- множество инцидентов, которые переводят объект из одной стадии в другую (событий);
- множества действий, которые мы связываем с состоянием(перевести объект в это состояние);
- правила перехода;

Что из себя представляет модель состояния? Мы ее можем оформить либо диаграммой, либо таблицей.
## Диаграмма переходов состояний

**ДПС** - диаграмма переходов состояний. Состояние на этой таблице рисуется прямоугольником.

Каждому состоянию мы присваиваем:
- уникальный номер
- имя состояния.
#### Виды состояния:
- **Состояние создания** - такие состояния, в которых объект появляется первый раз. Переход в такие состояния переходит не из состояния.
- **Заключительное состояние**. Возможно два варианта заключительных состояний:
	- **Объект уничтожается**. Это состояние на диаграмме рисуется пунктирной линией.
	- **Состояние, из которых объект уже не переходит в другие состояния**. Дальнейшего поведения у объекта нет, но он не уничтожается! На диаграмме оно рисуется таким же прямоугольником, но перехода из него в другое нет.
- **Текущее состояние**. Чтобы определять текущее состояние, мы в класс добавляем вспомогательный атрибут, который определяет это состояние. Его называют статусом.

>Переход из одного состояния в другое у нас переходит в результате возникновения какого-то события - инцидента, который приводит к изменению состояния объекта, перехода из одного в другое. На диаграмме событие рисуется стрелочкой из того, которое было до этого, в то, в которое мы переходим.
#### Описание события:
- **Значение события** - короткое событие, отвечающее на вопрос: "Что происходит?".
- **Предназначение события.** Мы четко событие связываем с каким-либо объектом.
- **Метка события** (номер).
- **Данные события**. Событие может переносить данные. Данные могут быть причем двух типов: идентифицирующие данные и любые другие атрибуты, причем не обязательно только того объекта, для которого происходят события.

#### Правила связи события с состоянием:
- Все события, которые переводят объект в данное состояние, должны нести одни и те же данные. С каждым состоянием мы связываем действие, которое должно выполняться при переходе объекта в состояние.
- События никогда не теряются. Если объект выполняет какое-то действия, то события откладывается и будет выполнено после окончания действия.
- Правило состояния создания: то событие, которое переводит в состояние создания, не несет идентификатора объекта. 
- Правило состояния не создания: оно должно нести идентификатор объекта.

## Действия

Теперь по поводу действия. Каждому состоянию мы ставим в соответствие действие. **Задача действия - перевести объект в то состояние, которому оно соответствует.** Что делает действие? Оно может выполнять любые операции над атрибутами самого объекта. Кроме того, выполнять любые вычисления. Действие может порождать события для любого объекта любого класса, в том числе и для самого себя. В том числе порождать события для чего-либо вне области анализа нашей подсистемы. выполнять любые действия над таймером: выполнять создавать считывать, запускать таймер, очищать таймер.

Мы не накладываем ограничений. **Действие имеет доступ к любым атрибутам объектов любых классов**. На этом этапе мы не ограничиваем действие! Ограничения возникнут позже.
#### Что обязано действие:

1. Гарантировать непротиворечивость объекта, то есть после выполнения действия атрибуты объекта не должны противоречить друг другу.
2. При создании и удалении объектов собственного класса действие должно позаботиться о связях, чтобы они тоже были не противоречивыми.
3. Действие должно менять атрибут состояния - статус на то состояние, в которое мы переходим.

>Когда мы выделили состояние, мы можем четко описать, что должно произойти, чтобы перевести в это состояние. Мы можем проанализировать связи с другими объектами - кому интересно, что мы изменили своё состояние? Мы можем описать алгоритм действия.

>Алгоритм действия можно разместить на ДПС непосредственно под самим состоянием, если оно короткое. Описание действия - псевдокод (как правило, используют псевдокод аля Паскаль). Если алгоритм большой - выносим его с ДПС.

>Для данного объекта в данный момент времени может выполняться только одно действие. Если объекты разные, то у них разные действия могут выполняться одновременно. Если событие порождено для объекта, который в данный момент выполняет действие, то оно будет принято объектом только после того, как действие будет выполнено. Но события никогда не теряются. Событие исчезает после того, как оно было принято. вот что касается жизненных циклов.

## Таблица переходов состояний. ТПС.

С помощью ТПС мы контролируем, какие возможны переходы из одного состояния в другое. **В ТПС каждая строка - это состояние, в котором может находиться объект, столбец - это событие.** Состояния нужно не забыть пронумеровать, у каждого состояния есть свой уникальный номер.

#### Варианты заполнения ячеек:

- В какое состояние объект перейдет в результате возникновения события в этом состоянии? В ячейке пишем **номер состояния**, в которое переходит объект.
- У нас может быть ситуация, когда событие игнорируется, то есть в этом состоянии объект игнорирует событие. Событие происходит - никакого перехода не происходит. В этом случае мы ставим **прочерк**.
- Еще одно возможное заполнение ячейки (лучше чтобы их не было) - данное событие не может произойти, если объект находится в этом состоянии. Ставим **крестик** (не плюсик).
## ТПС и ДПС на примере таймера:

![[timer.png]]

>**Любое атипичное поведение должно обрабатываться, как типичное. Если возникает такой случай, то нужно добавлять новые состояние, то есть необходимо бороться с исключительными ситуациями.

#### Когда мы выделяем состояние, надо четко помнить, что у каждого состояния есть какая-то цель: зачем нам нужно это состояние?

>У нас могут возникать **состояния контекста - промежуточные состояния, которые определяются предыдущим и следующим состоянием**, и их цель - сформировать этот переход, чтобы у нас был скачкообразный переход из одного состояния в другое.
## Для каких объектов формируются жизненные циклы

- Если мы свели жизненный цикл на уровень супер класса - это идеально. Тогда мы рисуем только одну диаграмму.
- Но если подклассы имеют все таки свои жизненные циклы... в этом случае надо для каждого подкласса реализовать диаграмму.
- И есть третий случай: когда часть поведения определяется суперклассом, и могут быть какие-то отличия связанные с подклассом. Таким образом, мы рисуем жизненный цикл... и часть будет для супер класса, и отличия для подкласса.

## Когда мы выделяем жизненные циклы или формируем модель поведения

- Для пассивных объектов мы не выделяем жизненные циклы, но иногда делаем в интересах активных объектов.
- Объекты спецификаций - жизненные циклы не выделяются (расписание дня, движения поездов).
- Если это задача или запрос - выделяем.
- Динамическая связь - связь имеющая динамическое поведение - выделяем ассоциативный объект и формируем для него жизненный цикл.
- Если объект создается по этапно - да (состояния стройки).
- Любое оборудование, которое имеет четкое выделяемое состояние (любой бытовой прибор).

>Первый этап информационного моделирования - выделение суперкласса за счет общих атрибутов. Потом окажется, возможно, что объекты, которые не имеют общих атрибутов, имеют общий жизненный цикл, ну или у них есть общие части. В этом случае мы должны вернуться к информационному моделированию и выделить суперкласс не за счет общих атрибутов, а за счет общего поведения.

>И возможна такая ситуация, когда мы выделили одну сущность, но разные объекты этой сущности, хотя атрибуты одни и те же, имеют разное поведение. В таком случае, мы должны относить их к разным классам. Опять возвращаемся информационному моделированию и выделяем суперкласс, а объекты относим к какому-либо из подклассов.

