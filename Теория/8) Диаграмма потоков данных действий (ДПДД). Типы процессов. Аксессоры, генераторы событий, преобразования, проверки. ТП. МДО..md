>**Полная формулировка вопроса:** Диаграмма потоков данных действий (ДПДД). Типы процессов: аксессоры, генераторы событий, преобразования, проверки. Таблица процессов (ТП). Модель доступа к объектам (МДО).

В ДПС мы определили алгоритм действий, которые переводят объекты в состояния. Для описания этого алгоритма на ДПС можно использовать псевдокод или выносить его отдельно в виде схемы алгоритма.
## Диаграмма потоков данных действий

![[dpdd.png]]

> Каждое действие мы можем выделить как процесс, который происходит. Каждый процесс отвечает на вопрос: "Что он делает"? Вычисляет, проверяет и так далее.
> 
> Пишем ключевой литерал `A`, номер процесса `1`, определяем, что он делает - `Вычислить sum := 0`. Таким образом, мы выделили процесс, который вычисляет `sum`.
> 
> Далее, у нас идет цикл.
> 
> Раздел инициализации. Процесс `2`.
> 
> Выражение `i < count` - тоже процесс. Но, чтобы проверить `i`, нам нужно его получить, то есть процесс `А.3` должен выполняться после `А.2`. Рисуем стрелочку, соединяющую процессы, и рисуем рядом данное, которое передается. В данном случае это `(i)` в круглых скобках, так как оно рассматривается, как неустойчивое данное, то есть оно используется только во время выполнения нашего действия. После того, как действие выполнится, данное не будет существовать. Пока не выполнится `A.2`, процесс `A.3` не сможет выполниться.
> 
> В зависимости от проверки `A.3` возможно 2 варианта.
> 
> `A.4` - `Вычислить sum := sum + arr[i]^2`. Этот процесс использует условие `A.3`. У нас идет условное управление, поэтому перечеркиваем линию и пишем условие `i < count`. Откуда нам взять count? Данные самого объекта рассматриваются, как архив данных. Доступ должен происходить к данным через процесс, поэтому заведем `A.5` - `Считать count`. Так же нам еще нужна сумма, берем её из `A1`.
> 
> После того, как вычислили сумму, увеличиваем инкремент- `A.6`. Пунктирная стрелка говорит о том, что процесс `A.6` может выполниться только тогда, когда выполнен этот процесс `A.4`.
> 
> На выходе получаем результат и отправляем его в терминатор.

## Важные моменты

- Стрелками мы показываем потоки данных, если направлены к процессу – то входные данные, если от – то выходные. Мы всегда помечаем стрелочку теми данными, которые передаются. Каждая стрелочка - это одно данное
    
- Если мы читаем атрибуты самого объекта, то мы просто записывем имя атрибута. Если это объект того же класса, но это другой объект, ИЛИ это объект другого класса, то имя надо аннотировать впереди идентификатора, например, `array.count` - это будет говорить о том, что это другой объект, а не тот же самый.
    
- Считывание данных атрибута самого объекта, другого объекта того же класса или других классов мы рассматриваем как архив данных.
    
- Процесс может принимать событие или порождать. Процесс, который принимает событие – стрелка в него из ниоткуда с пометкой, что за событие. Процесс, который порождает событие, пускает стрелочку в никуда.
    
- Бывают безусловные и условные потоки управления. Безусловные указывают только на порядок, в котором должны выполнятся действия, передача данных не происходит.
    
- Устойчивые и неустойчивые данные. Если данное порождается во время выполнения действия, его отмечают как неустойчивое. Данные из архива устойчивы, все другие – неустойчивые(их мы берем в круглые скобки).
    
- Процесс и данное. Процесс может считывать данное из архива, может записывать. Но так же любой процесс может брать данное из какой то внешней сущности, и так же возвращать (пример на рисунке с терминатором).

## Правила выполнения процессов:

- Процесс может выполниться, когда все вводы доступны
- Вывод процесса доступен, когда процесс выполнился
- Данные событий (которые приводят к выполнению) всегда доступны
- Данные из архивов данных и данные терминаторов всегда доступны
## Выделяют 4 типа процессов

- Аксессоры – единственная цель – получить данные. Он может их получить из архива данных или из какой-то внешней сущности. 
	- Создания
	- Уничтожения
	- Чтения
	- Записи
- Генераторы событий – процесс, который создает на выходе событие.
- Преобразования – процесс, который выполняет какие-либо преобразования данных, вычисления.
- Проверки – результат – условный переход.

>Данные из терминаторов, из архива данных, данные из событий всегда доступны. А так процесс может выполниться только тогда, когда все входы доступны.

## Таблица процессов состояний

Многократное использование процессов. Наша задача выявить одни и те же процессы, которые происходят в нашей подсистеме с разными объектами разных классов. 
#### Когда выделяют такие процессы:
- выполняют одну и ту же функцию 
- читают и записывают одни и те же атрибуты
- принимают как ввод одни и те же атрибуты от терминаторы
- создают как вывод одни и те же атрибуты
- порождают одни и те же события
- одинаковые выводы условного управления

>Элементы таблицы по порядку: ID процесса, Тип, Название процесса, Где используется: модель состояний/Действие.

>Напомним, что один и тот же процесс может использоваться в разных моделях состояний и в разных действиях. Выделив процессы, являющиеся общими для разных моделей состояний, мы можем выделять действия, которые присущи этой модели состояния НО не являющиеся обработчиками состояния.

>Если в разных моделях состояния происходят одни и те же процессы, надо говорить о том, что эти модели состояния могут быть родственны, объединены общей базой. Тогда эти действия мы можем вынести на уровень базы. Если это процессы, которые происходят в моделях состояний, который не объединены(не относятся к подклассам), то в таком случае решением может быть выделение их общей базой(выделением суперклассом) или использование паттернов, которые позволят нам вынести этот процесс вне, чтобы можно было использовать общий процесс для разных моделей состояния.

## Модель доступа к объектам

Модель доступа к объектам строится когда один объект взаимодействует с аксессором другого объекта. Получает доступ к данным другого объекта. При проектировании аксессорные процессы заменяются на методы: констурктор, деструктор, get, set.

![[mdo.png]]

>На схеме пусть, например, объект А использует аксессор объекта Б, значит стрелка от А к Б. Аксессор может быть любым(создание, уничтожение, чтение, запись)

>В результате мы получили модель доступа к объектам, в таблице процессов мы выделили общие процессы и представили алгоритм в виде взаимодействия процессов с учетом условного/безусловного управления и передачи данных. Всё вместе - это ДПДД.

>З.Ы. Получается так, что мы используем дпдд немного для другого. Изначально Де-Марко в 70-ых дпдд расписал для того, чтобы понять какие процессы могут выполняться одновременно и с учетом того, что данный процесс может выполниться когда доступны данные для выполнения процесса. Мы же дпдд используем не для распараллеливания, а чтобы выделить эти процессы.