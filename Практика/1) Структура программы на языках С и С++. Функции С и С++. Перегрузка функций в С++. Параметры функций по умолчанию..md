 
Программа состоит из набора файлов, который включает в себя объявление определений.

### Существуют абстракции по:

- **По действию:
	- Функции - можем объявлять и определять
- **По данным:
	- Типы данных - можем объявлять и определять
	- Переменные - можем объявлять и определять
	- Константы

>Выполнение программы как правило начинается с ф-ции “main”, она обязательно должна присутствовать. Существуют приоритеты выполнения ф-ций.

>Функции могут быть вложенными. Любая ф-ция может вызвать любую другую ф-цию, в том числе и саму себя (кроме main).

>Для использования файлов реализации, все что мы хотим использовать необходимо сначала определить, либо объявить в том месте, где хотим использовать. Для удобства создаются заголовочные файлы, в кот. выносятся определения.


![[comp.png ]]


## Заголовочный файл

**Заголовочные файлы** - описание типов, констант, библиотеки, функций, логически вынесенных в другой исходный файл.

#### Что можно, а что нельзя определять в заголовочном файле:

- **Нельзя определять переменные**. Мы конечно можем это сделать, и на этапе компиляции проблем не будет, но сборщик покажет множественное определение, что является ошибкой.
- То же самое касается функций. В заголовочном файле описываются **только прототипы функций**.
- К языковой константе компилятор относится как к макросу, поэтому в заголовочном **можно определять константу**.
- Аналогично с типами - **типы тоже можно определять в заголовочном файле**.

>То есть все константы и типы выносим в заголовочный, а так же прототипы функций.

## Компиляция программы

>Объявления необходимы компилятору. Объявлять можно один раз, определять - сколько угодно. Компилятор подставляет константы.

>В С и С++ каждый файл компилируется раздельно, либо с помощью makefile.

**Получение исполняемого файла  ==`*.exe`==:**
1. **Препроцессирование** - удаление комментариев, замена `#define`, подключение заголовочных файлов `*.h` (путем копирования содержимого). Для избежания повторного копирования используется `#pragma once` или `#ifndef G_H`.
    
2. **Компиляция** - перевод написанного на языке C++ кода в код ассемблера.
    
3. **Ассемблирование** - перевод из кода ассемблера в машинный код. Получаем объектный файл с расширением `*.obj`.
    
4. **Компоновка/линковка** - объединение объектных файлов в один исполняемый `*.exe`.

>`#pragma once` исключает множественное включение файлов.

## Перегрузка функций. Параметры.

**Перегрузка функций** – возможность создавать функции с одними и теми же названиями. Можно определить функцию, которую необходимо вызвать по количеству параметров, или по типу данных аргументов.

>Значение из функции может быть возвращено непосредственно, либо через аргумент.

#### На перегрузку функции влияет:
	- Разное количество принимаемых параметров.
	- Разный тип переменных.
	- const значение функции/метода. Если объект константный, то будет вызываться const метод, иначе не const.

>Примечание о том, что значит модификатор const у метода. Константный метод - это метод, который гарантирует, что не будет изменять объект или вызывать неконстантные методы класса (поскольку они могут изменить объект). Соответственно, для константных объектов нельзя вызывать неконстантные методы.

>Тип возвращаемой переменной не имеет значение.

```c++
//  Пример функции возведения в квадрат
int sqr(int x);  // для целых
double sqr(double x); // для дробных
int sqr(const int x) const; // для const  целых 
```

**Пример:**
```c++
# include <iostream>

using namespace std;

void func1(int& x) { cout << "func1(int&)" << endl; }
void func1(const int& x) { cout << "func1(const int&)" << endl; }

void func2(int x) { cout << "func2(int)" << endl; }
void func2(int& x) { cout << "func2(int&)" << endl; }

void func3(const int& x) { cout << "func3(const int&)" << endl; }
void func3(int&& x) { cout << "func3(int&&)" << endl; }

void func4(int& x) { cout << "func4(int&)" << endl; }
void func4(int&& x) { cout << "func4(int&&)" << endl; }

void func5(int x) { cout << "func5(int)" << endl; }
void func5(int&& x) { cout << "func5(int&&)" << endl; }

void func6(int x) {}
void func6(const int& x) {}

int main()
{
	int i = 0;
	const int ci = 0;
	int& lv = i;
	const int& clv = ci;
	int&& rv = i + 1;
	
	func1(i);// int&
	func1(ci);// const int&
	func1(lv);// int&
	func1(clv);// const int&
	func1(rv);// int&
	func1(i + 1);// const int&
	cout << endl;
	
	//func2(i);// Error!
	func2(ci);// int
	//func2(lv);// Error!
	func2(clv);// int
	//func2(rv);// Error!
	func2(i + 1);// int
	cout << endl;
	
	func3(i);// const int&
	func3(ci);// const int&
	func3(lv);// const int&
	func3(clv);// const int&
	func3(rv);// const int&
	func3(i + 1);// int&&
	cout << endl;
	
	func4(i);// int&
	//func4(ci);// Error!
	func4(lv);// int&
	//func4(clv);// Error!
	func4(rv);// int&
	func4(i + 1);// int&&
	cout << endl;
	
	func5(i);// int
	func5(ci);// int
	func5(lv);// int
	func5(clv);// int
	func5(rv);// int
	//func5(i + 1);// Error!
	
	//func6(i);// Error!
	//func6(ci);// Error!
	//func6(lv);// Error!
	//func6(clv);// Error!
	//func6(rv);// Error!
	//func6(i + 1);// Error!
}
```

#### Параметры по умолчанию

> В Си++ один или несколько аргументов функции могут задаваться по умолчанию. Для каждого параметра значение по умолчанию можно указать не более одного раза, но каждое последующее объявление функции, а также определение функции может назначать параметрам значения по умолчанию. **Параметры по умолчанию должны быть последними в списке параметров**.