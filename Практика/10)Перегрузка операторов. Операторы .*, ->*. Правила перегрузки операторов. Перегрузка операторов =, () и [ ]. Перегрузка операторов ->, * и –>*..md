## Идея

>Задать новую операцию на основе существующего оператора. Это позволяет не заботится об используемом литерале, приоритете, арности и т.д.

>Мы должны задать знак операции, сказать, какая это операция (указать арность). Она может быть унарной, бинарной, тернарной. Операция может выполняться либо слева направо, либо справа налево. Операции имеют приоритет.

>Мы не можем задавать новые операторы, а на основе существующих операторов создавать новые операции, то есть перегружать оператор.

### Какие операторы нельзя перегружать

Шесть операторов, которые перегружать нельзя:

1. **Оператор `.`** - доступ к члену объекта. Если мы перегрузим этот оператор, мы не сможем вызвать для объекта ни одного метода!
2. **Оператор `.*`** - указатель на метод.
3. **Оператор `::`** - оператор доступа к контексту. Он применяется для доступа к членам через имя класса или для доступа к глобальному контексту.
4. **Оператор `? :`** - тернарный оператор. Разработчики просто не смогли придумать, как перегрузить этот оператор. Страуструп не пришел ни к одному из решений.
5. **Оператор `sizeof`** - определение размера объекта. Если мы перегрузим, то не сможем определять размеры объектов.
6. **Оператор `typeid`** - возвращает id типа объекта. Если мы перегрузим, мы не сможем идентифицировать объект и понять, какого он типа.
### Операторы `.*` и `->*`

>С++ добавляет два интересных оператора. Напомним, что оператор `.*` перегружать нельзя, а оператор `->*` можно.

Посмотрим на очень интересный пример с функциями:

```c
void f();     // Определили функцию f()
void (*pf)(); // Определили указатель на функцию
pf = f;		  // Этот указатель инициализируем адресом функции(так как имя любой функции - это ее адрес в памяти)
pf();         // Через указатель на функцию вызываем функцию
```

>Примечание: оператор `()` - оператор разыменования - вызов функции по адресу. Так же вызвать функцию f() можно и таким образом: `(*pf)()` - синтаксис позволяет.

Что касается методов класса:

```c
void A::f();     // Метод класса A
void (A::*pf)(); // Указатель на метод класса A

// Хотелось бы проинициализировать этот указатель.
// pf = A::f; - Если мы таким образом напишем, мы получим не адрес этого метода
// Метод не находится в классе. Он вызывается по указателю, и чтобы получить этот адрес, 
// было принято решение добавить вот такой синтаксис
pf = &A::f;  // Вычисление адреса метода.

A obj; 
(obj.*pf)(); // Чтобы вызвать метод через указатель, используется оператор .*
			 // Этот указатель имеет более низкий приоритет, чем (),
             // поэтому, чтобы использовать (),
             // надо повысить его приоритет, взяв obj.*pf в круглые скобки.

A* p = &obj;
(p->*pf)();  // Оператор ->* используется для указателя на объект
             // В метод, на который указывавет этот указатель, будет передаваться
             // указатель на объект.
```

>Таким образом, мы разделяем вызов функции и вызов метода. Если мы вызываем метод класса через указатель для объекта, используется оператор `.*`, а если работаем с указателем на объект, используется оператор `->*`.

1. **Операторы, которые можно перегрузить только как члены классов**:
    1. **Оператор `=`** - оператор присваивания (бинарный)
    2. **Оператор`()`** - функтуатор (бинарный), банарный, так как стек
    3. **Оператор `[]`** - индексация (бинарный)
    4. **Оператор `->`** - унарный
    5. **Оператор `->*`** - бинарный, так как принимает указатель на метод и объект, метод которого вызываем
2. **Бинарные операторы можно перегружать как члены класса или как внешние функции-операторы.** Это зависит от ситуации. Конечно, надо отдавать предпочтение члену класса. Если мы перегружаем бинарный оператор, как член класса, он принимает 1 параметр (второй параметр он принимает неявно - `*this`).
3. **Унарные операторы перегружаем как члены класса.**

```c++
class Array {

... public:

    bool operator==(const Array& arr) const;

... 
};

// Первый вариант - перегрузка оператора, как члена класса
bool Array::operator==(const Array& arr) const {...}

// Второй вариант - перегрузка оператора, как внешней функции
bool Array::operator!=(const Array& arr1, const Array& arr2) const {...}
```

## Операторы =, `[]`, ()

```c++
class Array
{
private:
	double* mas;
	int cnt;
public:
	Array& operator=(const Array& arr);
	Array& operator=(Array&& arr);

	int operator ()(const A& a) const {return compare(*this, a)}

        // Мы можем перегружать оператор как для константных, так и не для константных. 
	double& operator[](const Index& index); 
	//const double& operator[](const Index& index) const;
};

Array& Array::operator=(const Array& arr) // оператор присваивания с копированием - создает копию объекта
{
	if( this == &arr ) return *this; // проверка на то, что это не один и тот же объект.
	
	delete []mas;
	cnt = arr.cnt;
	mas = new double[cnt];
	memcpy(mas, arr.mas, cnt*sizeof(double));
	
	return *this;
}

Array& Array::operator=(Array&& arr) // оператор присваивания с переносом - захватывает временный объект
{
	delete []mas; // освободить
	
	cnt = arr.cnt;
	mas = arr.mas;
	arr.mas = nullptr;
	
	return *this;
}

double& Array::operator[](const Index& index)
{
	if(index < 0 || index >= cnt) throw std::out_of_range("Error: class Array operator [];"); 
	return mas[index]; // index должен быть типа int, он типа Index.
                           // Но т.к. определен оператор приведения типа к типу int происходит неявное приведение к типу int
}
```

## Перегрузка -> и `*`.

Оператор `->` перегружается как член класса, он унарный, принимающий один параметр - в данном случае this будет принимать, и должен возвращать либо указатель, либо ссылку на объект.

```c
class A
{
public:
	void f();
};

class B
{
public:
    A* operator->();
};

// Создадим объект где-то в коде и вызовем оператор ->
// Такая запись будет означать: оператор возвращает указатель на объект класса A
// и для него, для объекта, мы вызваем метод f()
B obj;
obj->f(); // (obj.operator->())->f()
```

### Пример реализации - использование оператора `->`.

Объект класса B по существу является прозрачной оболочкой. Мы через объект B работаем с методами класса `A`. Совместно с указателем `->` еще перегружается оператор `*`. Он помогает делать примерно то же самое - возвращает ссылку на объект, и по ссылке мы уже вызываем метод. Мы можем перегружать эти операторы как для константных, так и для не константных объектов.

```c
class A
{
public:
	void f() const { cout<<"Executing f from A;"<<endl; }
};

class B
{
private:
	A* pobj;
public:
	B(A* p) : pobj(p) {}
	A* operator->() { return pobj; }
	const A* operator->() const { return pobj; }
	A& operator*() { return *pobj; }
	const A& operator*() const { return *pobj; }
};

void main()
{
	A a;
	B b1(&a);
	b1->f(); // (b1.operator->())->f()
	const B b2(&a);
	(*b2).f(); // (b2.operator*()).f()
}
```

Оператор`->.` может возвращать так же ссылку в том случае, если этот класс, на который она возвращает ссылку, содержит перегруженный оператор `->.`

Рассмотрим пример ниже:

```c
class A
{
public:
	void f() { cout<<"Executing f from A;"<<endl; }
};

class B
{
private:
	A* pobj;
public:
	B(A* p) : pobj(p) {}
	A* operator->() { cout<<"B -> "; return pobj; }
};

class C
{
private:
	B& alias;
public:
	C(B& b) : alias(b) {}
	B& operator->() { cout<<"C -> "; return alias; }
};

void main()
{
	A a;
	B b(&a);
	C c(b);
	c->f(); // ((c.operotor->()).operator->())->f() сначала возвращаем ссылку на b,
                // потом возвращаем указатель на a, потом вызываем метод f() по указателю
}
```