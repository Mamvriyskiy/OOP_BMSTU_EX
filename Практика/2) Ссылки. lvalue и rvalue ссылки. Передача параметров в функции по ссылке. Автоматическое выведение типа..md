## Ссылки

>**Структуру по значению передавать плохо**, так как происходит копирование в стек, а это занимает время. Лучше по ссылке или указателю. Но у указателей есть проблема - контроль (сложно проверить корректность, только на NULL).

**Ссылка (alias)** - ещё одно имя того же самого данного. **Ссылка - не тип данных!**

```c++
// Пример, демонстрирующий принцип работы ссылки
int i;
int& ai = i;
ai = 2;       // аналогично, что i = 2;
```

>Ссылки используются для передачи параметра в функцию. На низком уровне ссылки хоть ничем не отличается от указателя, но идет контроль!

>Нельзя возвращать ссылку на локальную переменную. Возврат по ссылке нужен для формирования левого выражения = , чтобы присвоить переменной нужное значение.

```c++
int i;
int &ai = i;
ai = 2; // i = 2;
// int &  - левая ссылка
// int && - правая ссылка

int i = 0;
const int c = 0;

int &lv1 = i;
const int &clv1 = c;
const int& clv2 = i + 1; // создается новая ячейка памяти

int &&rv1 = i; // Error
int &&rv2 = i + 1;
++rv2; // можем изменять содержимое данной области

int &&rv3 = rv2; // Error
int &lv2 = rv2;
int &&rv4 = i + 0; // ссылка на копию i
int &&rv5 = (int) i; // ссылка на копию i

// получить правую ссылку из любого выражения:

int &&rv6 = std::move(i);
```

#### Rvalue-ссылки
```c++
# include <iostream>

using namespace std;

int main()
{
	int i = 0;
	int&& rv1 = i + 0;
	int&& rv2 = move(i);
	int&& rv3 = (int)i;
	
	++i;
	
	int&& rv4 = 5;
	++rv4;
	
	cout << "rv1 = " << rv1 << "; rv2 = " << rv2 << "; rv3 = " << rv3 << endl;
	cout << "rv4 = " << rv4 << endl;
}
```


>Ссылки используются для передачи параметра в функцию. На низком уровне ссылки хоть ничем не отличается от указателя, но идет контроль.

```c++
void swap(double &d1, double &d2)
{

    double temp = d1;
   d1 = d2;
   d2 = temp;

}

swap(arr[i], arr[j]);
```

## Автоматическое приведение типов

>Начиная с C++11 ключевое слово auto при инициализации переменной может использоваться вместо типа переменной, чтобы сообщить компилятору, что он должен присвоить тип переменной исходя из инициализируемого значения. Это называется выводом типа (или «автоматическим определением типа данных компилятором»).

```c++
auto x = 4.0; // 4.0 - это литерал типа double, поэтому и x должен быть типа double 
auto y = 3 + 4; // выражение 3 + 4 обрабатывается как целочисленное, поэтому и переменная y должна быть типа int
```

>Это работает даже с возвращаемыми значениями функций:

```c++
int subtract(int a, int b) {
	return a - b;
}

int main() 
{
	auto result = subtract(4, 3); // функция subtract() возвращает значение типа int и, следовательно, переменная result также должна быть типа int
	return 0; 
}
```

>Переменные, объявленные без инициализации, не могут использовать эту особенность (поскольку нет инициализируемого значения, и компилятор не может знать, какой тип данных присвоить переменной).

```c++
# include <iostream>

int main()
{
	int i = 0;
	const int ci = 0;
	int& lv = i;
	const int& clv = ci;
	int&& rv = i + 1;
	
	// тип int
	{
	auto x1 = i;
	auto x2 = ci;
	auto x3 = lv;
	auto x4 = clv;
	auto x5 = rv;
	auto x6 = i + 1;
	}
	
	// тип int&
	{
	auto& refx1 = i;
	auto& refx3 = lv;
	auto& refx5 = rv;
	}
	
	// тип const int&
	{
	auto& crefx2 = ci;
	auto& crefx4 = clv;
	}
	
	// тип const int&
	{
	const auto& crefx1 = i;
	const auto& crefx2 = ci;
	const auto& crefx3 = lv;
	const auto& crefx4 = clv;
	const auto& crefx5 = rv;
	const auto& crefx6 = i + 1;
	}
	
	// тип int&
	{
	auto&& refx1 = i;
	auto&& refx3 = lv;
	auto&& refx5 = rv;
	}
	
	// тип const int&
	{
	auto&& crefx2 = ci;
	auto&& crefx4 = clv;
	}
	
	// тип int&&
	{
	auto&& refx6 = i + 1;
	}
}
```