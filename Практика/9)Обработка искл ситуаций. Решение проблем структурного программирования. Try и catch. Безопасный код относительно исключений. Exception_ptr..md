>**Полная формулировка вопроса:** обработка исключительных ситуаций в С++. Решение проблем структурного программирования. Блоки try и catch. Блоки try и catch методов и конструкторов. Безопасный код относительно исключений. Обертывание исключения в exception_ptr. Задачи, которые может решать исключение. Проблемы с динамической памятью при обработке исключительных ситуаций.
#### Недостатки обработки ошибок в структурном программировании

1. Если где-то возникает ошибка в коде, мы вынуждены "протащить" ее через все уровни абстракции/иерархии до того места, пока мы не сможем обработать эту ошибку.
2. Весь код насыщен непрерывными проверками. Обработка ошибки совмещена вместе с кодом.

>Идея в том, чтобы при возникновении какой-либо ошибки передавать управление непосредственно в то место, где мы можем обработать ее, не "протаскивая" ее через много уровней.
#### Обработка ошибок в C++

Инструкции обработки ошибок:
- **Инструкция `try`** - заворачиваем в неё блок кода, в котором может произойти ошибка, и берём его под контроль.
- Если в блоке `try` возникает исключительная ситуация, мы можем перейти на **обработчик `catch`**. Обработчики идут непосредственно после блока `try`.
- Генерируем исключительную ситуацию, используя **инструкцию `throw`**.

>Здесь нет приведения типов, т.е. жесткая типизация, за исключением перевода ссылки с базового класса на производный, и указателя с базового на производный. Обработчиков может быть несколько.

>Обработчиков может быть несколько. Обработчик принимает объект какого-либо типа. Соответственно, если объект, который мы передаем в `throw` или создаем `throw`, может быть принят обработчиком (тип совпадает или приводится к этому типу), вызывается этот обработчик. Если не может, он передается следующим обработчикам до тех пор, пока не выберется блок `catch`. Если на этом уровне ни один из `catch` не перехватил этот объект, то это передается на более высокий уровень. Ошибка может никем не перехватиться, в этом случае программа "падает".

>**Мы можем перехватить любые исключительные ситуации, используя `catch` с 3 точками**. Этот обработчик должен быть в конце списка, иначе он перехватит любую ситуацию, и другие обработчики ниже не будут работать.

```c++
try
{
    // код
    ---> throw <объект>  // Возникла исключительная ситуация и мы выходим на обработчик
    // код
}
catch  (<тип>& <объект>) // Если объект совпадает с типом или приводится к этому типу,
{						 // вызывается обработчик
    // код
}
catch  (<тип>& <объект>) // иначе переходим к следующему обработчику
{						 // до тих пор пока не найдем нужный catch
    // код
}
catch  (...) // Перехват любых исключаительных ситуаций
{
    // код
}
```

>При пробросе все статические переменные уничтожаются, однако динамические не будут освобождены.
#### Задачи обработчика
1. **Выдать сообщение пользователю или записать его в log-файл**.
    - Время ошибки
    - Где она произошла
    - Что за ошибка
    - Возможно, данные, которые привели к этой ошибке

2. Задача обработчика - по возможности обработать ситуацию, но ошибка может быть критической. В этом случае на обработчик возлагается **функция корректного завершения программы** (например, нормально закрыть БД, чтобы не потерять данные).
#### Безопасный относительно исключений код должен представлять одну из трех гарантий:

1. Функции, предоставляющие базовую гарантию, обещают, что если исключение будет возбуждено, то все в программе остается в корректном состоянии. Никакие объекты или структуры данных не повреждены, и все объекты находятся в непротиворечивом состоянии. Однако точное состояние программы может быть непредсказуемо.
    
2. Функции, предоставляющие строгую гарантию, обещают, что если исключение будет возбуждено, то состояние программы не изменится. Вызов такой функции является атомарным; если он завершился успешно, то все запланированные действия выполнены до конца, если же нет, то программа останется в таком состоянии, как будто функция никогда не вызывалась.
    
    Работать с функциями, представляющими такую гарантию, проще, чем с функциями, которые дают только базовую гарантию, потому что после их вызова может быть только два состояния программы: то, которое ожидается в результате ее успешного завершения, и то, которое было до ее вызова. Напротив, если исключение возникает в функции, представляющей только базовую гарантию, то программа может оказаться в любом корректном состоянии.
    
3. Функции,предоставляющие гарантию отсутствия исключений, обещают никогда не возбуждать исключений, потому что всегда делают то, что должны делать. Все операции над встроенными типами (например, целыми, указателями и т. п.) обеспечивают такую гарантию. Это основной строительный блок безопасного относительно исключений кода. Разумно предположить, что функции с пустой спецификацией исключений не возбуждают их, но это не всегда так.
## std::exception_ptr:

Этот тип позволяет в себе хранить исключение абсолютно любого типа. Его поведение сходно c std::shared_ptr: его можно копировать, передавать в качестве параметра, при этом само исключение не копируется. Основное предназначение exception_ptr — это передача исключений в качестве параметров функции, возможна передача исключений между потоками. Таким образом, объекты данного типа позволяют сделать обработку ошибок более гибкой.

#### Проблема с динамической памятью при обработке исключительных ситуаций

В C++, перейдя на обработчик, мы не можем вернуться в место возникновения ошибки (все временные объекты будут уничтожены). Предположим, у класса А есть метод f(). Если мы динамически выделили память:
```c++
try
{
    A* obj = new A; // Динамически выделили память под объект
    obj->f();       // Если внутри функции f() произошла ошибка и мы вышли на обработчик,
    delete obj;     // происходит утечка памяти
}
```

Если при вызове метода f() возникает исключительная ситуация и мы выходим на какой- то из обработчиков, объект obj не удаляется. Происходит утечка памяти.

Два варианта решения проблемы:
```c++
void A::f() noexcept // Первый способ
void A::f() throw()  // Второй способ
```

>Модификатор noexcept «дает обещание» компилятору не обрабатывать исключение, тогда вызывается специальный метод terminate, задача которого очистить стек. Метод terminate() приводит к тому, что будут вызываться все деструкторы только временных объектов в порядке, обратном их созданию.

Со throw результат непредсказуем, это старый синтаксис, его лучше не использовать.
- Если пишем noexcept без параметров аналогичен noexcept(True) - это говорит о том, что данный метод не должен обрабатывать исключительную ситуацию.
    
- Если пишем noexcept(False) или throw(...), то этот метод может обрабатывать все исключительные ситуации, как и в случае если ничего не пишем.
    
>Любой деструктор по умолчанию не бросает исключения, т.к. может выйти бесконечный вызов деструктора. В блоке catch можно писать throw, тогда исключения необходимо ловить в «старшем» блоке.

>std::exception содержит виртуальный метод what, и на основе него мы можем создавать свои классы. От него есть производный класс ошибок std::bad_alloc. При создании своих производный классов мы придерживаемся такого подхода, что отдельный класс обрабатывает только одну ситуацию. Даже стандартные ошибки мы будет перекладывать на себя, создавая свои.
    
Исключения решают следующие задачи:
- Исключают необходимость прокидывания ошибок через много уровней, все делает обработчик
- Разделяют логику программы от обработки ошибок, выносы обработчики отдельно
- Позволяют легко модифицировать и развивать ПО
- Буквально контролируют работу программы: создание объектов и выполнение
    
### Определение исключительных ситуаций, которые метод может обрабатывать

Можно указать, какую исключительную ситуацию метод может обрабатывать.

```c
void A::f() throw(<тип>)
```

**Этот метод может обрабатывать все исключительные ситуации с этим типом и производными от него.**

### Исключительная ситуация в деструкторе

>**Вызов исключительной ситуации из деструктора - опасная вещь**, может привести к непредсказуемым ситуациям. Если идет генерация исключительной ситуации, то эту ситуацию надо обрабатывать сразу в деструкторе.

### Несколько обработчиков одной исключительной ситуации

>Ситуацию можно "протащить". Например, обработчик принял объект, но не смог полностью обработать ситуацию. Мы можем "прокинуть" ее до следующего обработчика, который может принять этот объект:

```c
catch(<тип>& <объект>)
{
    // код
    throw; // Объект прокидывается дальше
}
```

>Объект принимается везде по ссылке => объект должен создаваться исключительно при вызове исключительной ситуации. Время жизни этого объекта ограничивается этим блоком.

### Исключительная ситуация в разделе инициализации объекта

>Если мы говорим о теле конструктора, то тело выполняется после создания объекта, и если возникает исключительная ситуация после создания объекта, то все корректно. Но если она возникает в разделе инициализации, когда объекта еще нет, возникает проблема.

Чтобы было корректно, **конструктор можно "обернуть" в `try` и для него сделать обработчик**:

```c
Array::Array() try <раздел инициализации>
{
    // тело конструктора
}
catch(<тип>& <объект>)
```

Пишем это не при объявлении, а при инициализации конструктора.