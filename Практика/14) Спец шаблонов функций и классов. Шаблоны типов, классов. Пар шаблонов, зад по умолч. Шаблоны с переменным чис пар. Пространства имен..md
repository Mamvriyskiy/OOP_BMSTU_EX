>Полная формулирова вопроса: Специализация шаблонов функций. Шаблоны типов. Шаблоны классов. Полная или частичная специализация шаблонов классов. Параметры шаблонов, задаваемых по умолчанию. Шаблоны с переменным числом параметров. Пространства имен.

Шаблонный тип. В языке Си для задания имени типа использовался typedef. Это аналог определения какой-либо переменной, только вместо этого - имя типа.

Например, определим имя для типа, принимающего указатель на функцию, принимающую int и возвращающую void:
```c++
typedef void (*Tpf)(int);
```

>В языке С++ шаблон на основе typedef мы определить не можем. Добавляется еще одна конструкция - using, выполняющая ту же функцию, что и typedef. После using записываем имя типа, а далее записывается так называемый абстрактный описатель (определение переменной без ее имени).

```c++
using Tpf = void (*)(int);
```

Две вышеприведенные записи с typedef и using эквивалентны, но для typedef мы не можем определить шаблон. Пример шаблонного типа:
```c++
template<typename T>
using cmp_t = int(*) (const T&, const T&);
//...
cmp_t<double> v;
```

#### Определение шаблона класса:
```c++
template <typename T>
class A
{
    T elem;
public:
	void f(); 
};
```

>Методы шаблона класса также являются шаблонами. В принципе, у нас может быть нешаблонный класс, но с шаблонными методами, то есть в обычном классе можно определить шаблонный метод. Шаблонные методы поддерживают шаблон класса. Методы будут создаваться только для того типа, которого класс. Не будет проблемы срезания ссылок.

Так же, как и у любой функции, у шаблона метода может быть специализация.

>Для вызовов методов действует такое же правило, как и для функций: сначала для созданного класса, если есть специализация выбирается специализация, если нет специализации, создается метод по шаблону.

Полная специализация.

```c++
template <typename T>
class A {...};

template <>
class A<float> {...};
```

>Специализация является тоже шаблоном. По специализации так же создается класс, если нужно. У нас создаются классы по специализации. Специализация может иметь отличные параметры от шаблонов, вернее тело специализации может быть другим: другие члены, данные, методы, отличные от самого шаблоны.
#### Полная специализация шаблона класса и метода шаблона класса.
 
```c++
# include <iostream>

using namespace std;

template <typename Type>
class A
{
public:
	A() { cout << "constructor of template A;" << endl; }
	void f() { cout << "metod f of template A;" << endl; }
};

template <>
void A<int>::f() { cout << "specialization of metod f of template A;" << endl; }

template <>
class A<float>
{
public:
	A() { cout << "specialization constructor template A;" << endl; }
	void f() { cout << "metod f specialization template A;" << endl; }
	void g() { cout << "metod g specialization template A;" << endl; }
};

int main()
{
	A<double> obj1;
	obj1.f();
	
	A<float> obj2;
	obj2.f();
	obj2.g();
	
	A<int> obj3;
	obj3.f();
}

```

>Частичная специализация - когда мы указываем не все значения параметра шаблона. При частичной специализации шаблонов возможна неоднозначность при вызове. Здесь аналогичный подход с функциями: сначала идет выбор специализации, если невозможно создать класс по специализации, создается класс по шаблону.

#### Частичная специализация шаблона класса, параметры шаблона класса по умолчанию.

```c++
# include <iostream>

using namespace std;

template <typename T1, typename T2 = double>
class A
{
public:
	A() { cout << "constructor of template A<T1, T2>;" << endl; }
};

// Specialization #1
template <typename T>
class A<T, T>
{
public:
	A() { cout << "constructor of template A<T, T>;" << endl; }
};

// Specialization #2
template <typename T>
class A<T, int>
{
public:
	A() { cout << "constructor of template A<T, int>;" << endl; }
};

// Specialization #3
template <typename T1, typename T2>
class A<T1*, T2*>
{
public:
	A() { cout << "constructor of template A<T1*, T2*>;" << endl; }
};


int main()
{
	A<int> a0;// Template
	A<int, float> a1;// Template
	A<float, float> a2;// Specialization #1
	A<float, int> a3;// Specialization #2
	A<int*, float*> a4;// Specialization #3

	//A<int, int> a5;// Error!!!
	//A<int*, int*> a6;// Error!!!
}
```

>Так же, как при определении функций, параметры шаблона могут быть по умолчанию. В случае выше сам шаблон имеет один параметр по умолчанию - double. Если мы передаем только один параметр, будет вызываться этот шаблон (а второй параметр по умолчанию типа double):

```c++
template <typename T1, typename T2 = double>
class A {
public:
	A() { cout << "constructor of template A<T1, T2>;" << endl; } };
```

#### Шаблоны с переменным числом параметров
Так же как функции, шаблоны мы можем создавать с переменным числом параметров. Это могут быть шаблоны функций, методов и классов.

Если мы рассматриваем для классов, чтобы в классах были инициализаторы с несколькими параметрами. В принципе, можно использовать `initializer_list`, если параметры одного типа. А если разного?

И, если говорить о классах, используются так называемые кортежи, когда мы формируем какой-то тип из полей разных типов. Мы не всегда знаем то данное, которое нам нужно возвращать, какие параметры могут входить в это данное. Мы можем возвращать список данных, формировать структуру, причем можем, конечно, формировать список данных разного типа. Кортеж - хорошая альтернатива, когда мы объединяем по надобности параметры разного типа в одно данное.

```c++
template <typename Type>
Type sum(Type value) {
	return value;
}

template <typename Type, typename ...Args> 
Type sum(Type value, Args... args) {    
	return value + sum(args...);
}

int main()  {
	cout << sum(1, 2, 3, 4, 5) << endl;
	return 0;
}
```

## Пространство имен 

>Программа растет, она становится большой. Во время разрастания программы может возникнуть проблема конфликта имён. Мы используем разные библиотеки, в одной библиотеке нужно что-то взять, в другой что-то взять. у некоторых библиотек может дублироваться функционал. Это типичная ситуация. Например, несколько реализаций функции с именем swap в различных библиотеках. Когда подключаем разные библиотеки, может возникнуть конфликт имен. Из какой библиотеки мы вызываем swap? Это так же может касаться имен классов, методов, которые мы используем.

В C++ мы можем задавать пространства имён. Синтаксис такой:

```c++
namespace <имя>
{
<блок пространства имён>
}

// Доступ к пространству имён
<имя>::f(); // f() - член пространства имен
```

Или можно сделать так:

```c++
// или можно включить это пространство и использовать f

using namespace <имя>;  
f(); // но таким образом можно вернуться к изначальной проблеме
```

>В примере выше тоже можно натолкнуться на проблему конфликта имён, так как подключив несколько namespace, может возникнуть та же самая ситуация. Поэтому, когда у нас есть много пространств имён с пересекающимися параметрами, лучше использовать синтаксис :: - это поможет избежать конфликта.

>Пространствами имён злоупотреблять не надо. Вложенных пространств имён надо избегать или сводить к минимуму.

>Имя пространства имён может отсутствовать — это анонимные пространства имён. Их особенность в том, что из другого файла нельзя получить доступ к членам анонимного пространства имён. Грубо говоря, если у нас часть, и мы не хотим, чтобы она была видна из других частей, мы можем определить это, как анонимное пространство имен.