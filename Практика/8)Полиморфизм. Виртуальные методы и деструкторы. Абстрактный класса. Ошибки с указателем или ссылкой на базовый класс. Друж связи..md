>**Полная формулировка вопроса:** Полиморфизм в С++. Виртуальные методы. Чисто виртуальные методы. Виртуальные и чисто виртуальные деструкторы. Понятие абстрактного класса. Ошибки, возникающие при работе с указателем или ссылкой на базовый класс. Дружественные связи.

## Полиморфизм

**Полиморфизм** – возможность подменять одно другим, не изменяя написанный код. Возможность обработки разных типов данных, с помощью "одной и той же" функции, или метода.

>Если в классе определен хотя бы один метод с модификатором virtual, то данный класс считается полиморфом и при создании объектов этих классов в них добавляется указатель на виртуальную таблицу, то есть на те методы, которые использует класс.

>Ключевое слово override дает гарантию того, что метод является полиморфом и подменяет метод базового класса.

```c++
using namespace std;

class A
{
public:
	virtual void f() { cout << "Executing f from A;" << endl; }
};

class B : public A
{
public:
	void f() override { cout << "Executing f from B;" << endl; }
};

class C
{
public:
	static void g(A& obj) { obj.f(); }
};

void main()
{
	B obj;
	
	C::g(obj);
}

```

## Абстрактный класс

> Базовый класс всегда должен быть абстрактным. Его объекты создавать нельзя. Для того, чтобы создать абстрактный класс, в нем должен быть хотя бы один чисто виртуальный метод. Он задается следующим образом:

```c++
public:
    virtual void f() = 0;
```

>Таким образом, производные классы должны подменить этот метод. Если они не реализуют этот метод, они тоже будут абстрактными.

>Базовый класс всегда должен содержать виртуальный деструктор. Чисто виртуальный деструктор:

```c++
# include <iostream>

using namespace std;

class A
{
public:
	virtual ~A() = 0;
};

A::~A() = default;

class B : public A
{
public:
	~B() override { cout << "Class B destructor called;" << endl; }
};

void main()
{
	A* pobj = new B;
	delete pobj;
}
```

>Нельзя вызывать виртуальные методы в конструкторах и деструкторах. Так как может возникнуть ситуация, когда объекта еще нет или уже нет, поэтому будет вызываться уже другой метод.
## Ошибки, возникающие при работе с указателями на базовый класс:

- Подобъект может находится по другому адресу самого объекта внутри объекта. Если это произошло, то следующий код может выдавать непредсказуемый ответ:
```c++
A *pa = 0;
B *pb = 0;
if (pa == pb)
```

- Может случайно вызваться конструктор копирования(в данном примере для класса A):
```c++
void f(A obj);

B obj;
A &alias = obj;
f(alias);
```

Поэтому для полиморфного класса необходимо запретить/определить копирование с explicit.

- Нельзя работать с массивами объектов, вместо этого необходимо создавать структуры с указателями на объекты.

```c++
A &index(A *arr, int i)
{
    return arr[i];
}

B *ar = new B[10];
A obj  = index(B, 2);
```
## Дружественные связи

>В современных объектно-ориентированных языках понятие дружбы нет, так как дружба делает зависимыми два класса.

>Что такое дружба? Мы можем дать возможность объектам одного класса дать доступ ко всем членам другого класса, прописав его как друг этого класса. У нас даже наследники не имеют доступа ко всем членам, а друг имеет!

>Дружба не наследуется и дружба не транзитивна (друг моего друга мне не друг).

>Дружба может приводить к жесткой зависимости классов

#### Дружба и наследование

```c++
class C; // forward объявление

class A
{
private:
	void f1() { cout<<"Executing f1;"<<endl; }

	friend C; // Мы говорим, что у нас есть друг - класс C. Все методы класса C будут иметь доступ ко всем членам
    		  // класса A
};

class B : public A
{
private:
	void f2() { cout<<"Executing f2;"<<endl; }
};

class C
{
public:
	static void g1(A& obj) { obj.f1(); } // Метод, который принимает ссылку на объект класса А
    									 // В нём мы имеем доступ к этому методу
    
	static void g2(B& obj) // Получаем ссылку на объект класса B - производный от класса A
	{
		obj.f1(); // f1() мы можем вызвать - мы имеем доступ ко всем членам класса 
//		obj.f2(); // Error!!! Имеет доступ только к членам A
	}
};

class D : public C
{
public:
//	static void g2(A& obj) ( obj.f1(); } // Error!!! Дружба не наследуется
};


void main()
{
	A aobj;

	C::g1(aobj);

	B bobj;

	C::g1(bobj);
	C::g2(bobj);
}
```

#### Дружба и виртуальные методы

```c++
class C; // forward объявление

class A
{
protected:
	virtual void f() { cout<<"Executing f from A;"<<endl; }

	friend C;
};

class B : public A
{
protected:
	virtual void f() override { cout<<"Executing f from B;"<<endl; }
};

class C
{
public:
	static void g(A& obj) { obj.f(); } // Друг принимает ссылку на объект класса А, а мы передаем объект класса B.
    								   // Будет вызываться метод, который подменяет производный.
};

void main()
{
	B bobj;

	C::g(bobj);
}
```

>Дружба - это не очень хорошо. Мы вынуждены изменять класс, так как не можем от него отнаследоваться. И будем вынуждены для друга посмотреть все методы, как они работают с объектами этих классов, разобраться, внести в них изменения. Это плохо. Мы можем ограничить дружбу, дать доступ какому либо методу.

```c++
class A
{
    friend void  f(C* pc); //друг - внешняя функция
    friend void A::f(); // Наш выбор! друг - метод класс
    friend class B; //друг - класс
};
```

>Другом класса может быть функция, метод из класса или класс. Приоритет надо отдавать варианту, когда мы делаем какой-то определённый метод класса другом. Таким образом, если класс С меняется, нам не нужно будет просматривать весь класс А, а только вносить изменения в конкретный метод. Дружба приводит к тому, что если вносить изменения, надо изменять написанный код. Надо проектировать таким образом, чтобы не вносить изменения в написанный код.