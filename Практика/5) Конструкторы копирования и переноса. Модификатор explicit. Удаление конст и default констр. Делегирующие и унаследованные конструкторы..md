>**Полная формулировка вопроса:** Конструкторы копирования и переноса. Модификатор explicit. Удаление конструктора и default конструктор. Делегирующие и унаследованные конструкторы.

```c++
# include <iostream>

using namespace std;

class Array
{
private:
    double* arr;
    int count;

public:
    Array() = default;
    Array(int cnt) : count(cnt) { arr = new double[count] {}; }
    Array(const Array& ar); //конструктор копирования
    Array(Array&& ar) noexcept; //конструктор переноса
    ~Array();

    bool equals(Array ar);

    static Array minus(const Array& ar);
};

Array::Array(const Array& ar) : count(ar.count)
{
    arr = new double[count];

    for (int i = 0; i < count; ++i)
        arr[i] = ar.arr[i];
}

Array::Array(Array&& ar) noexcept : count(ar.count)
{
    arr = ar.arr;

    ar.arr = nullptr;
}

Array::~Array()
{
    delete[] arr;
}

bool Array::equals(Array ar)
{
    if (count != ar.count) return false;

    int i;
    for (i = 0; i < count && arr[i] == ar.arr[i]; ++i);

    return i == count;
}

Array Array::minus(const Array& ar)
{
    Array temp(ar);

    for (int i = 0; i < temp.count; ++i)
        temp.arr[i] *= -1;

    return temp;
}


int main()
{
    Array mas{ 10 };

    if (mas.equals(Array::minus(mas)))
    {
        cout << "true" << endl;
    }
    else
    {
        cout << "false" << endl;
    }
}
```

>Обычный конструктор используется для той или иной инициализации объекта, он не должен вызываться для копирования уже существующего объекта, так как такой вызов изменит содержимое объекта (передаст объект в начальном состоянии), а мы хотим передать функции текущее состояние объекта, то есть нужен конструктор копирования.

>Когда мы передаем в функцию какой-то объект по ссылке, конструктор не вызывается. Когда мы возвращаем объект из какой-либо функции (не по ссылке), если этот объект создается внутри этой функции, тоже вызывается конструктор копирования.

>Конструктор копирования должен принимать в качестве параметра объект того же класса. Причем параметр лучше принимать по ссылке, потому что при передаче по значению компилятор будет создавать копию объекта. А для создания копия объекта будет вызываться конструктор копирования, что приведет бесконечной рекурсии.

>Конструктор переноса и оператор переноса был добавлен в C++ 11. Основная идея применения этих двух конструкций состоит в том, чтобы ускорить выполнение программы путем избегания копирования данных при начальной инициализации и присвоении так называемых rvalue-ссылок.

>Конструктор переноса и оператор переноса целесообразно объявлять в классах, содержащих большие массивы данных.

>Если в классе не реализован конструктор переноса, то его вызов заменяется конструктором копирования.

Общая форма объявления конструктора переноса в классе:
```c++
ClassName(ClassName&& rObj) noexcept
{
...
}
```
rObj – ссылка на ссылку на временный экземпляр класса, значение которого будет скопировано в текущий экземпляр.

>В приведенной выше общей форме используется ключевое слово noexcept. Этот спецификатор указывает, что наш конструктор переноса не генерирует исключение или аварийно завершает свою работу. Компилятор рекомендует использовать слово noexcept для конструктора переноса. В конструкторе переноса не происходит никаких операций с памятью, а происходит простое присвоение указателя.

>Если перед именем конструктора поставить слово explicit, это будет гарантировать, что конструктор неявно не вызовется. Все конструкторы с 1 параметром должны быть с этим модификатором, это позволяет избежать случайного приведения типов.

>Если мы определили конструктор копирования, то конструктор переноса не создается по умолчанию.  Некоторые компиляторы после определения конструктора копирования требуют определить конструктор переноса.

#### Default

>Ключевое слово default введено в C++ 11. Его использование указывает компилятору самостоятельно генерировать (использовать) соответствующую функцию класса, если таковая не объявлена в классе.

>Общая форма использования ключевого слова default:

```c++
class ClassName
{
// ...
    ClassName(parameters) = default;
// ...
};
```
#### Delete

>Ключевое слово delete используется в случаях, когда нужно запретить использование какого-либо конструктора, тогда его вызов приведет к ошибке.

>Общая форма объявления конструктора класса с ключевым словом delete:

```c++
class ClassName
{
// ...
    ClassName(parameters) = delete;
// ...
};
```
#### Наследование конструкторов

Конструкторы не наследуются. В производном классе необходимо переопределить конструкторы.

```c
class MyArray: public Array
{
public:
    using Array::Array;	// Определяем в производном классе конструкторы базового класса
}
```

#### Ограничения для конструкторов и деструкторов

**Конструкторы:**
- не могут быть `const`, `static`, `volatile`, `virtual`
- могут быть `cosntexpr` (вычисляется на этапе компиляции), `explicit` (вызывается только явно)

> Из Герберта Шилдта. Описатель volatile сообщает компилятору, что значение переменной может измениться, хотя в программе нет предложений, явным образом модифицирующих эту переменную, например, программа обработки прерываний от таймера может, получив адрес глобальной переменной, обновлять ее с каждым тактом таймера.

**Деструкторы:**
- не могут быть `const`, `static`, `volatile`.
- могут быть `virtual`.

Деструктор вызывается не явно. Деструктор уничтожает объект в порядке, обратном порядку создания.

 