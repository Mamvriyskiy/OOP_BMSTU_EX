>Полная формулировка вопроса: Ограничения, накладываемые на шаблоны. Требования к шаблонам (requires). Концепты. Типы ограничений. Варианты определения шаблонов функций и классов с концептами.

Ограничения шаблонов (как функций, так и классов) позволяют ограничить набор возможных типов, которые будут применяться параметрами шаблонов. Добавляя ограничения к параметрам шаблона, решаются следующие задачи:
- Из заголовка шаблона сразу видно, какие аргументы шаблона разрешены, а какие нет.
- Шаблон создается только в том случае, если аргументы шаблона удовлетворяют всем ограничениям.
- Любое нарушение ограничений шаблона приводит к сообщению об ошибке, которое гораздо ближе к первопричине проблемы, а именно к попытке использовать шаблон с неверными аргументами.

**Какие есть требования:**
- Функции, вычисляемые на этапе компиляции(которые возвращают True или False, функция, которая выполнится или не выполнится)
- Выражение, вычисляемое на этапе компиляции
- блок  requires, вычисляется на этапе компиляции. Если в requires есть еще один блок requires, то будет выполняться проверка, то есть компилятор не вычисляет, а просто проверяет.

>Начиная со стандарта С++20 в язык был добавлен оператор requires, который позволяет установить для параметров шаблонов ограничения.

```c++
template <параметры> requires ограничения содержимое шаблона;
```

```c++
template <typename T> requires std::is_same<T, int>::value || std::is_same<T, double>::value 
T sum(T a, T b){ return a + b;}

int main() {

    std::cout << sum(3, 4) << std::endl;
    std::cout << sum(12.5, 4.3) << std::endl;
    //std::cout << sum(5l, 7l) << std::endl;

}
```

>Начиная со стандарта C++20 в язык С++ была добавлена такая функциональность как concepts (концепты). Концепты позволяют установить ограничения для параметров шаблонов (как шаблонов функций, так и шаблонов класса).

>Концепт фактически представляет шаблон для именованного набора ограничений, где каждое ограничение предписывает одно или несколько требований для одного или нескольких параметров шаблона. В общем случае он имеет следующий вид:

```c++
template <параметры>
concept имя_концепта = ограничения;
```

>Список параметров концепта содержит один или несколько параметров шаблона. Во время компиляции компилятор оценивает концепты, чтобы определить, удовлетворяет ли набор аргументов заданным ограничениям.

```c++
template <typename T>
concept size = sizeof(T) <= sizeof(int);
```
#### Концепты бывают 4 видов:
1. Простые  
2. Составные 
3. Типовые  
4. Вложенные

**Пример простого концепта:**
```c++
tempalte<typename T>
concept Incrementable = requires(T t)
{
	t++;
	++t;
}
```

**Пример сложного концепта:**
Требования накладываются на тип результата выражения, которое выполняется
```c++
tempalte<typename T>
concept Incrementable = requires(T t1, T t2)
{
	{t1 == t2} -> convertable_to<bool>;
	//{t1 == t2} -> same_as<bool>; // жесткое ограничение
	
}
```

**Пример типового концепта:**
Нужно определить алиасы для контейнера: тип параметров, итераторы, тип размера данных контейнера.
```c++
tempalte<typename T>
concept Incrementable = requires(T t)
{
	typename T::value_type;
}
```

**Пример вложенного концепта**
```c++
tempalte<typename T>
concept Incrementable = requires(T t)
{
	requires noexcept(++t); //вычисляемый, примеры выше проверяемые
}
```

#### Ограничения для функций

**Способы задания:**
```c++
template <typename T>
requires Incrementable<T>
T& inc(T& v) {return ++v};

T& inc(T& v) requires Incrementable<T> 
{...}
```

>Концепт можно наложить на параметр шаблона, то происходит срезание параметра. Если концепт содержит несколько параметров, то срезается всегда первый параметр.

```c++
template<Incrementable T>

auto& inc(Incrementable auto& v)
```

#### Ограничения для классов
**Способы задания:**

```c++
template<typename T>
requires Incrementable<T>
class A 
{
	...
};

template<Incrementable T>
class A 
{
	...
};
```

>Для концептов нет рекурсий. 
