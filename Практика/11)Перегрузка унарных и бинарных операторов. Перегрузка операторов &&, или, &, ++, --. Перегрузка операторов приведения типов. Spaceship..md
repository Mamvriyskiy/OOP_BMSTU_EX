>Полная формулировка вопроса: Перегрузка унарных и бинарных операторов. Проблемы с перегрузкой операторов &&, ||, ,, &. Перегрузка операторов ++, --. Перегрузка операторов приведения типов. Тривалентный оператор spaceship.

Перегрузка операторов – задание новой операции на основе существующего оператора. Это позволяет не заботится об используемом литерале, приоритете, арности и т.д. Есть операторы, которые нельзя перегружать, к ним относятся «.», «.*», «::», «?:» (тернарный), «sizeof», «typeid».

>**Бинарные операторы можно перегружать как члены класса или как внешние функции-операторы.** Это зависит от ситуации. Конечно, надо отдавать предпочтение члену класса. Если мы перегружаем бинарный оператор, как член класса, он принимает 1 параметр (второй параметр он принимает неявно - `*this`).

>**Унарные операторы перегружаем как члены класса.**
## Проблемы с &&, ||, ++, --

Не рекомендуется перегружать следующие три бинарных оператора: , (запятая), &&, ||. Дело в том, что для них стандарт предусматривает порядок вычисления операндов (слева направо), а для последних двух еще и так называемую семантику быстрых вычислений (short-circuit evaluation), но для перегруженных операторов это уже не гарантируется или просто бессмысленно, что может оказаться весьма неприятной неожиданностью для программиста. (Семантика быстрых вычислений заключается в том, для оператора && второй операнд не вычисляется, если первый равен false, а для оператора || второй операнд не вычисляется, если первый равен true.)

Также не рекомендуется перегружать унарный оператор & (взятие адреса). Тип с перегруженным оператором & опасно использовать с шаблонами, так как они могут использовать стандартную семантику этого оператора. Правда в С++11 появилась стандартная функция (точнее шаблон функции) std::addressof(), которая умеет получать адрес без оператора & и правильно написанные шаблоны должны использовать именно эту функцию вместо встроенного оператора.

## Перегрузка ++, --

**Идея:** отделить постфиксную от префиксной записи.

**Решение:** унарный - префиксный, бинарный - постфиксный операторы.

**Замечание:** _если мы бинарный не перегружаем, то и для постфиксного и префиксного будет вызываться перегруженный унарный оператор. Иначе мы четко разделяем их._

```c++
class A {
	int a;
public:
	A& operator ++() 
	{
		a++;
		return *this;
	}
	
	A operator ++(int) 
	{
		A tmp(*this)
		++a;
		return tmp;
	}
}
```

## Приведение типа

```c++
class A {
	explicit operator int(){return a}
	explicit operator B(){return a} //Может вызваться конструктор
}
```

>Нельзя делать цепочки приведения типов.

>Необходимо писать explicit для явного приведения типа

## Оператор Space ship

Используется для сравнения двух объектов:
```c++
(a <=> b) < 0 //trueifa<b
(a <=> b > 0 //truei fa>b  
(a <=> b) == 0 //true if a is equal/equivalent to b
```

>strong_ordering - сильное упорядочивание(int)
  weak_ordering - слабое упорядочивание
  partial_ordering - частичное упорядочивание(float - значения могут неравные, но эквивалентные(0 и -0))

>strong и weak возвращают 3 варианта: меньше, равно, больше. Partail возвращают 4 значения: больше, меньше, равно, несравнимые(потеря, переполнение порядка. Процессор работает с нормализованными числами, сопроцессор с денормализованными). 

```c++
class A {
	int a; //если здесь был бы тип auto стал типом partial_ordering
public:
	auto operator <=>(const A&) const = default;
}
```

```c++
# include <iostream>
# include <compare>

using namespace std;

class MyInt
{
private:
    int value;

public:
    MyInt(int val = 0) : value(val) {}

    //strong_ordering operator <=>(const MyInt& rhs) const
    //{
    //    return value <=> rhs.value;
    //}

    //strong_ordering operator <=>(const MyInt& rhs) const
    //{
    //    return value == rhs.value ? strong_ordering::equal :
    //            value < rhs.value ? strong_ordering::less :
    //                                strong_ordering::greater;
    //}
     
    //weak_ordering operator <=>(const MyInt& rhs) const
    //{
    //    return value == rhs.value ? weak_ordering::equivalent :
    //            value < rhs.value ? weak_ordering::less :
    //                                weak_ordering::greater;
    //}

    partial_ordering operator <=>(const MyInt& rhs) const
    {
        return value == rhs.value ? partial_ordering::equivalent :
            value < rhs.value ? partial_ordering::less :
            value > rhs.value ? partial_ordering::greater :
            partial_ordering::unordered;
    }

    bool operator ==(const MyInt&) const = default;
};

int main()
{
    MyInt a{ 1 }, b{ 2 }, c{ 3 }, d{ 1 };
    cout << "a < b: " << (a < b) << ", c > b: " << (c >= b) << endl;
    cout << "a < b: " << (a < b) << ", c > b: " << (c > b) << ", a != b: " << (a != b) << endl;
    cout << "a < 5: " << (a < 5) << ", 1 < c: " << (1 < c) << endl;
}

```