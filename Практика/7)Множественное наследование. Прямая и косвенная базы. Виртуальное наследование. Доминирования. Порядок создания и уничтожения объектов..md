>**Полная формулировка вопроса:** Множественное наследование. Прямая и косвенная базы. Виртуальное наследование. Понятие доминирования. Порядок создания и уничтожения объектов. Проблемы множественного наследования. Неоднозначности при множественном наследовании.
## Множественное наследование

Проблемы, возникающие без множественного наследования:
- Представим такую ситуацию: выстраиваем вертикальную иерархию, класс C наследуется от класса B, а B наследуется от класса A. В этом случае, в класс A мы должны вынести много того, что к понятию класса А не относится. Не совсем логично. **В случае со множественным наследованием (рис. ниже), мы четко разделяем понятия A и B. Такой подход уменьшает иерархию.**

- Второй момент (опять не используем множественное наследование). Мы можем не выносить что-то в базовый класс, а один из классов включить как подобъект, то есть не использовать наследование. Пусть С - производная от класса А и включает подобъект класса В. Тоже возникнет проблема - не будем иметь доступа к защищенным полям класса Б (нам придется делать это через методы класса Б) + придется протаскивать интерфейс для класса С класса Б.

## Прямая и косвенная базы

**Прямая база** - база относительно которой, мы непосредственно породили сущность.

**Косвенная база** - база, которая входит в нашу сущность, но от нее данная сущность непосредственно не породилась. Прямая база прямой базы.

>В производный класс прямая баз может входить только один раз, а косвенная сколько угодно.

## Виртуальное наследование 

```c++
class A{};
class B: virtual public A{};
class C: virtual public A{};
class D: public B, public C{};
```

![[abcd.png]]
 
>1. Если убрать первый virtual, то класс A будет рассматриваться, как подобъект класса D, то есть сначала создастся подобъект A для класса D, потом создастся B для D. Для C создастся A, для D создастся C.
>2. Если убрать второй virtual, то класс A не будет создаваться для класса D, создастся для классов А и B.
>3. Если оставить два virtual, то класс A создастся только для класса D. 

>Конструкторы виртуальных баз вызываются в первую очередь.

>Методы, определяемые в производных классах, доминируют над методами базовых классов. То есть они их подменяют. Почему так сделано. Если понадобилось в производном классе задать метод с таким же именем, то скорее всего он работает еще с какими-то членами производного класса. По этой причине в производном классе метод с таким именем перекрывает методы с таким же именем в базовом классе.

>Для решения этой проблемы можно использовать using. Но этого лучше не делать.

```c++
class B : public A
{
public:
	void f(int);
	using A::f;
}
```

#### Понятие доминирования
Тот метод, который в схеме определен ниже, **доминирует** над тем методом, который определен выше.



