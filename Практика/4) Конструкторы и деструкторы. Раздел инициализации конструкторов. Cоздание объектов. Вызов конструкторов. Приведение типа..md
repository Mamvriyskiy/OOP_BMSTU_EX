 > **Полная формулировка вопроса:** Создание и уничтожение объектов в С++. Конструкторы и деструкторы. Раздел инициализации конструкторов. Способы создания объектов. Явный и неявный вызов конструкторов. Приведение типа.

## Создание и уничтожение объектов
```c++
# include <iostream>

using namespace std;

class A
{
private:
    int value = 1;

public:
    A() { value *= 2; }
    A(const A&) { value *= 3; }
    A(A&&) noexcept { value *= 4; }
    ~A() { cout << value << endl; }
};

A f(A obj) { return obj; } //возврат через перенос value = 4

A f1() { return A(); }

A f2()
{
    A obj;

    return obj;
}

int main()
{
    cout << "prim 1" << endl;
    {
        A obj; //value = 2;

        f(obj); //вызывается копирование value = 3
		//Вывод: 4 3 2
    }
    cout << "prim 2" << endl;
    {
        A obj = f1(); //возврат простого конструктора
        //Вывод: 2
    }
    cout << "prim 3" << endl;
    {
        A obj = f2(); //возврат объекта по значению
        //Вывод: 2
    }
}
```


>После создания объекта сразу должна пройти его инициализация, для этого мы используем специальные методы – конструкторы. Его вызов может быть как явным, так и неявным. По умолчанию создается конструктор без параметров, конструктор копирования, и конструктор переноса. Конструктор – метод, который не имеет типа возврата, его имя совпадает с именем класса.

```c++
<имя класса>::<имя конструктора>([параметры])[:<раздел инициализации>]
{  
}
```
### Когда используется конструктор

- Когда определяем объект (неважно какой, внешний или внутренний)
- Когда идёт приведение типов
- Когда передаем в метод по значению или возвращаем по значению
- Когда динамически выделяем память, используя оператор new (явный вызов).
 
**Пример:**
```c++
class A
{
private:

   int a;
   const int cb;
   static int sc;
   static const int scd = 1;

public:
    A(int i);

};

int A::sc = 0;

A::A(int i): a(i) cb(i) {} //sc(i), scd(i)

A::A(int i): a(i) cb(i) {
	a = i;
	cb = i //Error, так как должна быть проинициализирована при создании обьекта
	sc = i;
	scd = i; //Error, так как const 
} 
```

>Порядок, который мы написали в разделе инициализации не влияет на порядок создания объектов.
### В любом классе нужно явно определить
- Конструктор копирования
- Конструктор переноса
- Деструктор
- Оператор присваивания
 
>Для уничтожения объектов используются деструкторы. Он порождается по умолчанию. Как и оператор присваивания. Для создания/удаления объектов используются операторы языка new, delete. Они возвращают типизированный указатель (в отличие от void в C). Рассмотрим следующий класс:

```c++
# include <iostream>

using namespace std;

class Array
{
private:
    double* arr;
    int count;

public:
    Array() = default;
    Array(int cnt) : count(cnt) { arr = new double[count] {}; }
    Array(const Array& ar); //конструктор копирования
    Array(Array&& ar) noexcept; //конструктор переноса
    ~Array();

    bool equals(Array ar);

    static Array minus(const Array& ar);
};

Array::Array(const Array& ar) : count(ar.count)
{
    arr = new double[count];

    for (int i = 0; i < count; ++i)
        arr[i] = ar.arr[i];
}

Array::Array(Array&& ar) noexcept : count(ar.count)
{
    arr = ar.arr;

    ar.arr = nullptr;
}

Array::~Array()
{
    delete[] arr;
}

bool Array::equals(Array ar)
{
    if (count != ar.count) return false;

    int i;
    for (i = 0; i < count && arr[i] == ar.arr[i]; ++i);

    return i == count;
}

Array Array::minus(const Array& ar)
{
    Array temp(ar);

    for (int i = 0; i < temp.count; ++i)
        temp.arr[i] *= -1;

    return temp;
}


int main()
{
    Array mas{ 10 };

    if (mas.equals(Array::minus(mas)))
    {
        cout << "true" << endl;
    }
    else
    {
        cout << "false" << endl;
    }
}
```

#### Вызываем явно: 
- Конструктор  копирования, если идет захват ресурсов.
- Деструктор
-  Оператор присваивания
#### Функции деструктора:
- забота о связях
- освобождение ресурсов

Если перед именем конструктора поставить слово explicit, это будет гарантировать, что конструктор **неявно** не вызовется. Все конструкторы с 1 параметром должны быть с этим модификатором, это позволяет избежать случайного приведения типов.

**Явно** можно вызвать конструктор следующими способами:
```c++
<тип> <идентификатор> [(<параметры>)]; // A obj(); <тип> <идентификатор> {[параметры]};  
<тип> *<идентификатор> = new <тип>{(параметры)};  
<тип> <идентификатор> = <тип>{(параметры)};
```

**Неявно:**
```c++
<тип> <идентификатор> = <значение>; 
<тип> <идентификатор> = {(параметры)};
```

Любой конструктор - оператор приведения типа.
